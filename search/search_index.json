{"config":{"lang":["en","es"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FPGA Design with Verilog","text":""},{"location":"#contibuciones","title":"Contibuciones","text":"<p>Las contribuciones a este proyecto son bienvenidas en cualquier formato: informes de errores, comentarios, pull requests, etc.</p>"},{"location":"#colaboradores","title":"Colaboradores","text":"<ul> <li>Julisa Verdejo Palacios - LinkedIn - GitHub</li> <li>Guadalupe Alonso Contreras - LinkedIn - GitHub</li> <li>Ciro Fabian Bermudez Marquez - LinkedIn - GitHub</li> </ul>"},{"location":"revisiones/","title":"Revisiones","text":""},{"location":"revisiones/#combinacionales","title":"Combinacionales","text":"<ul> <li> <p> <code>look_up_table.md</code></p> <ul> <li> <code>lut1.v</code></li> <li> <code>lut2.v</code></li> <li> <code>lut4.v</code></li> <li> <code>lut5.v</code></li> <li> <code>lut_tb.v</code></li> </ul> </li> <li> <p> <code>multiplecor.md</code></p> <ul> <li> <code>mux2_1.v</code></li> <li> <code>mux4_1.v</code></li> <li> <code>mux4_1_v2.v</code></li> <li> <code>mux4_1_v3.v</code></li> <li> <code>mux256_to_1.v</code></li> <li> <code>mux4_1_tb.v</code></li> </ul> </li> <li> <p> 02_dec7seg</p> </li> <li> <p> <code>dec7seg.v</code></p> </li> <li> <code>dec7seg_v2.v</code></li> <li> <code>dec7seg_v3.v</code></li> <li> <code>dec7seg_tb.v</code></li> </ul>"},{"location":"documentacion/","title":"Documentaci\u00f3n","text":""},{"location":"documentacion/#contenido","title":"Contenido:","text":"<ul> <li> <p>1. Combinacional</p> <ul> <li>1.1. Look Up Tables</li> <li>1.2. Multiplexores</li> <li>1.3. Codificadores</li> <li>1.4. Decodificadores</li> <li>1.5. ROMs</li> <li>1.6. Sumadores</li> <li>1.7. Restadores</li> <li>1.8. Multiplicadores</li> </ul> </li> <li> <p>2. Secuencial</p> <ul> <li>2.1. Flip-Flops</li> <li>2.2. Contadores</li> <li>2.3. FSM Moore</li> <li>2.4. FSM Mealy</li> </ul> </li> <li> <p>3. Teor\u00eda</p> <ul> <li>3.1. Punto Fijo</li> <li>3.2. SCM</li> </ul> </li> </ul>"},{"location":"documentacion/combinacionales/","title":"Combinacional","text":""},{"location":"documentacion/combinacionales/codificador/","title":"Codificadores","text":""},{"location":"documentacion/combinacionales/decodificador/","title":"Decodificadores","text":""},{"location":"documentacion/combinacionales/decodificador/#1-codigos","title":"1. C\u00f3digos","text":"Tabla 1. Tabla de verdad para decodificador de 7 segmentos. Decimal \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(e\\) \\(f\\) \\(g\\) 0 1 1 1 1 1 1 1 1 0 1 1 0 0 0 0 2 1 1 0 1 1 0 1 3 1 1 1 1 0 0 1 4 0 1 1 0 0 1 1 5 1 0 1 1 0 1 1 6 1 0 1 1 1 1 1 7 1 1 1 0 0 0 1 8 1 1 1 1 1 1 1 9 1 1 1 0 0 1 1 A 1 1 1 0 1 1 1 B 0 0 1 1 1 1 1 C 1 0 0 1 1 1 0 D 0 1 1 1 1 0 1 E 1 0 0 1 1 1 1 F 1 0 0 0 1 1 1 Versi\u00f3n 1Versi\u00f3n 2Versi\u00f3n 3 dec7seg.v dec7seg_v2.v<pre><code>module dec7seg_v2 (\n  input      [3:0] binary,\n  output reg [6:0] leds       \n);\n\n  always @(binary) begin\n    if (binary == 4'd0) begin\n        leds = 7'b1111110;\n    end else if (binary == 4'd1) begin\n        leds = 7'b0110000; \n    end else if (binary == 4'd2) begin\n        leds = 7'b1101101; \n    end else if (binary == 4'd3) begin\n        leds = 7'b1111001; \n    end else if (binary == 4'd4) begin\n        leds = 7'b0110011; \n    end else if (binary == 4'd5) begin\n        leds = 7'b1011011; \n    end else if (binary == 4'd6) begin\n        leds = 7'b1011111; \n    end else if (binary == 4'd7) begin\n        leds = 7'b1110001; \n    end else if (binary == 4'd8) begin\n        leds = 7'b1111111; \n    end else if (binary == 4'd9) begin\n        leds = 7'b1110011; \n    end else if (binary == 4'd10) begin\n        leds = 7'b1110111; \n    end else if (binary == 4'd11) begin\n        leds = 7'b0011111; \n    end else if (binary == 4'd12) begin\n        leds = 7'b1001110; \n    end else if (binary == 4'd13) begin\n        leds = 7'b0111101; \n    end else if (binary == 4'd14) begin\n        leds = 7'b1001111; \n    end else if (binary == 4'd15) begin\n        leds = 7'b1000111; \n    end else begin \n        leds = 7'b0000000;\n    end\n  end\n\nendmodule\n</code></pre> dec7seg_v3.v<pre><code>module dec7seg_v3 (\n  input  [3:0] binary,\n  output [6:0] leds\n);\n\n  assign leds = (binary == 4'd0 ) ? 7'b1111110 :\n                (binary == 4'd1 ) ? 7'b1111110 :\n                (binary == 4'd2 ) ? 7'b1101101 :\n                (binary == 4'd3 ) ? 7'b1111001 :\n                (binary == 4'd4 ) ? 7'b0110011 :\n                (binary == 4'd5 ) ? 7'b1011011 :\n                (binary == 4'd6 ) ? 7'b1011111 :\n                (binary == 4'd7 ) ? 7'b1110001 :\n                (binary == 4'd8 ) ? 7'b1111111 :\n                (binary == 4'd9 ) ? 7'b1110011 :\n                (binary == 4'd10) ? 7'b1110111 :\n                (binary == 4'd11) ? 7'b0011111 :\n                (binary == 4'd12) ? 7'b1001110 :\n                (binary == 4'd13) ? 7'b0111101 :\n                (binary == 4'd14) ? 7'b1001111 :\n                (binary == 4'd15) ? 7'b1000111 :\n                                    7'b0000000 ;\n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/decodificador/#2-verificacion","title":"2. Verificaci\u00f3n","text":"dec7seg_tb.v<pre><code>`timescale 1ns / 100 ps\n`include \"hex_to_7seg.v\"\n\nmodule dec7seg_tb();\n  // Definicion de se\u00f1ales de entrada y salida\n  reg  [3:0] binary;\n  wire [6:0] leds;\n\n  //Instanciacion del modulo\n  hex_to_7seg dut(.binary(binary), .leds(leds));\n\n  // Variables para archivo, iteraciones y tiempo\n  integer write_data;\n  integer i;\n  time t;\n\n  initial begin\n    // Configuracion de archivos de salida\n    write_data = $fopen(\"dec7seg_tb_output.txt\",\"w\");\n\n    // Salida de simulacion y variables de salida\n    $dumpfile(\"dec7seg_tb.vcd\");\n    $dumpvars(0,dec7seg_tb);\n\n    // Configuracion de formato de tiempo\n    $timeformat(-9, 2, \" ns\", 10);\n\n    // Simular todas las combinaciones posibles\n    for (i = 0; i &lt; 16; i++) begin\n        binary = i; #20; t = $time;\n        $fdisplay(write_data,\"Time = %t, binary = %b, leds = %b\", t, binary, leds);\n    end\n\n    // Cerrar archivo de texto\n    $fclose(write_data);\n\n    // Terminar simulacion\n    $display(\"Test completed\");\n    $finish;\n\n  end\n\nendmodule;\n</code></pre>"},{"location":"documentacion/combinacionales/look_up_table/","title":"Look Up Tables","text":"","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#1-codigos","title":"1. C\u00f3digos","text":"","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#11-funcion-booleana","title":"1.1. Funci\u00f3n booleana","text":"\\[ f(A,B,C,D) = (\\overline{A}  \\cdot \\overline{B} \\cdot D) + (B \\cdot \\overline{C} \\cdot \\overline{D}) + (\\overline{A} \\cdot C \\cdot \\overline{D}) \\] Tabla 1. Tabla de verdad de funci\u00f3n boolena. Decimal \\(A\\) \\(B\\) \\(C\\) \\(D\\) \\(f\\) 0 0 0 0 0 0 1 0 0 0 1 1 2 0 0 1 0 1 3 0 0 1 1 1 4 0 1 0 0 1 5 0 1 0 1 0 6 0 1 1 0 1 7 0 1 1 1 0 8 1 0 0 0 0 9 1 0 0 1 0 10 1 0 1 0 0 11 1 0 1 1 0 12 1 1 0 0 1 13 1 1 0 1 0 14 1 1 1 0 0 15 1 1 1 1 0 <p>Download <code>lut1.v</code> </p> lut1.v<pre><code>module lut1(\n  input A,\n  input B,\n  input C,\n  input D,\n  output F\n);\n\n  assign F = (~A &amp; ~B &amp; D) | (B &amp; ~C &amp; ~D) | (~A &amp; C &amp; ~D);\n\nendmodule\n</code></pre>","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#12-diagrama-esquematico","title":"1.2. Diagrama esquem\u00e1tico","text":"Figura 2. Diagrama esquem\u00e1tico de circuito combinacional. lut2.v<pre><code>module lut2(\n  input A,\n  input B,\n  input C,\n  input D,\n  output F\n);\n\n  wire c1;\n  wire c2;\n  wire c3;\n\n  assign c1 = ~A &amp; ~B &amp;  D;\n  assign c2 =  B &amp; ~C &amp; ~D;\n  assign c3 = ~A &amp;  C &amp; ~D;\n  assign  F = c1 | c2 | c3;\n\nendmodule\n</code></pre>","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#13-minterminos","title":"1.3. Mint\u00e9rminos","text":"<p>Tambi\u00e9n se les conoce como suma de productos o SOP (Sum Of Products).</p> Tabla 2. Tabla de verdad. Decimal \\(A\\) \\(B\\) \\(C\\) \\(D\\) \\(f\\) ... ... ... ... ... 0 11 1 0 1 1 1 13 1 1 0 1 1 Versi\u00f3n 1Versi\u00f3n 2 lut4.v<pre><code>module lut4(\n  input A,\n  input B,\n  input C,\n  input D,\n  output reg F\n);\n\n  always @(A,B,C,D) begin\n    if ( ( A &amp; ~B &amp;  C &amp;  D) | (A &amp; B &amp; ~C &amp; D)  )\n      F = 1'b1;\n    else \n      F = 1'b0;\n    end\n  end\n\nendmodule\n</code></pre> lut5.v<pre><code>module lut5(\n  input A,\n  input B,\n  input C,\n  input D,\n  output F\n);\n\n  assign F = ( A &amp; ~B &amp;  C &amp;  D) | ( A &amp;  B &amp; ~C &amp;  D);\n\nendmodule\n</code></pre>","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#2-verificacion","title":"2. Verificaci\u00f3n","text":"","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#21-testbench","title":"2.1. Testbench","text":"<p>Download <code>lut_tb.v</code> </p> lut_tb.v<pre><code>`timescale 1ns / 100 ps\n`include \"lut1.v\"\n\nmodule lut_tb();\n  // Definici\u00f3n de se\u00f1ales de entrada y salida\n  reg A;\n  reg B;\n  reg C;\n  reg D;\n  wire F;\n\n  // Instanciacion del modulo\n  lut1 dut(.A(A), .B(B), .C(C), .D(D), .F(F));\n\n  // Variables para archivo, iteraciones y tiempo\n  integer write_data;\n  integer i;\n  time t;\n\n  initial begin\n    // Configuracion de archivos de salida\n    write_data = $fopen(\"lut_tb_output.txt\",\"w\");\n\n    // Salida de simulacion y variables de salida\n    $dumpfile(\"lut_tb.vcd\");\n    $dumpvars(0,lut_tb);\n\n    // Configuracion de formato de tiempo\n    $timeformat(-9, 2, \" ns\", 10);\n\n    // Simular todas las combinaciones posibles\n    for (i = 0; i &lt; 16; i = i + 1) begin\n        {A,B,C,D} = i; #20; t = $time;\n        $fdisplay(write_data,\"Time = %t, {A,B,C,D} = %b, X = %b\", t, {A,B,C,D}, F);\n    end\n\n    // Cerrar archivo de texto\n    $fclose(write_data);\n\n    // Terminar simulacion\n    $display(\"Test completed\");\n    $finish;\n\n  end\n\nendmodule\n</code></pre>","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#22-resultados","title":"2.2. Resultados","text":"lut_tb_output.txt<pre><code>Time =   20.00 ns, {A,B,C,D} = 0000, X = 0\nTime =   40.00 ns, {A,B,C,D} = 0001, X = 1\nTime =   60.00 ns, {A,B,C,D} = 0010, X = 1\nTime =   80.00 ns, {A,B,C,D} = 0011, X = 1\nTime =  100.00 ns, {A,B,C,D} = 0100, X = 1\nTime =  120.00 ns, {A,B,C,D} = 0101, X = 0\nTime =  140.00 ns, {A,B,C,D} = 0110, X = 1\nTime =  160.00 ns, {A,B,C,D} = 0111, X = 0\nTime =  180.00 ns, {A,B,C,D} = 1000, X = 0\nTime =  200.00 ns, {A,B,C,D} = 1001, X = 0\nTime =  220.00 ns, {A,B,C,D} = 1010, X = 0\nTime =  240.00 ns, {A,B,C,D} = 1011, X = 0\nTime =  260.00 ns, {A,B,C,D} = 1100, X = 1\nTime =  280.00 ns, {A,B,C,D} = 1101, X = 0\nTime =  300.00 ns, {A,B,C,D} = 1110, X = 0\nTime =  320.00 ns, {A,B,C,D} = 1111, X = 0\n</code></pre>","tags":["combinacionales"]},{"location":"documentacion/combinacionales/look_up_table/#3-referencias","title":"3. Referencias","text":"<ol> <li> <p>Russell, \u201cTutorial - Boolean Algebra using Look-Up Tables (LUTs)\u201d, Nandland, el 9 de junio de 2022. https://nandland.com/lesson-4-what-is-a-look-up-table-lut (consultado el 17 de julio de 2023).\u00a0\u21a9</p> </li> <li> <p>\u201cQuine\u2013McCluskey algorithm\u201d. https://www.mathematik.uni-marburg.de/~thormae/lectures/ti1/code/qmc (consultado el 17 de julio de 2023).\u00a0\u21a9</p> </li> <li> <p>\u201cGate Level Modeling\u201d, ChipVerify. https://www.chipverify.com/verilog/verilog-gate-level-modeling (consultado el 17 de julio de 2023).\u00a0\u21a9</p> </li> </ol>","tags":["combinacionales"]},{"location":"documentacion/combinacionales/memorias_rom/","title":"Memorias ROM","text":""},{"location":"documentacion/combinacionales/multiplexor/","title":"Multiplexor","text":""},{"location":"documentacion/combinacionales/multiplexor/#1-codigos","title":"1. C\u00f3digos","text":""},{"location":"documentacion/combinacionales/multiplexor/#11-multiplexor-2-a-1-de-n-bits","title":"1.1 Multiplexor 2 a 1 de n bits","text":"mux2_to_1.v<pre><code>module mux2_to_1 #(\n  parameter Width = 32\n) (\n  input  [Width-1:0] in1_i,\n  input  [Width-1:0] in2_i,\n  input              sel_i,\n  output [Width-1:0] mux_o\n);\n\n  assign mux_o = sel_i ? in2_i : in1_i;\n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/multiplexor/#11-multiplexor-4-a-1-de-n-bits","title":"1.1 Multiplexor 4 a 1 de n bits","text":"Versi\u00f3n 1Versi\u00f3n 2Versi\u00f3n 3 mux4_to_1.v<pre><code>module mux4_to_1 #(\n  parameter Width = 32\n) (\n  input  [Width-1:0] in1_i,\n  input  [Width-1:0] in2_i,\n  input  [Width-1:0] in3_i,\n  input  [Width-1:0] in4_i,\n  input        [1:0] sel_i,\n  output [Width-1:0] out_o\n);\n\n  assign out_o = sel_i[1] ? (sel_i[0] ? in4_i : in3_i) : (sel_i[0] ? in2_i : in1_i);\n\nendmodule\n</code></pre> mux4_to_1_v2.v<pre><code>module mux4_to_1 #(\n  parameter Width = 32\n) (\n  input      [Width-1:0] in1_i,\n  input      [Width-1:0] in2_i,\n  input      [Width-1:0] in3_i,\n  input      [Width-1:0] in4_i,\n  input            [1:0] sel_i,\n  output reg [Width-1:0] out_o\n);\n\n  always @(in1_i, in2_i, in3_i, in4_i, sel_i) begin\n    if (sel_i == 0) begin\n      out_o = in1_i;\n    end else if (sel_i == 1) begin\n      out_o = in2_i;\n    end else if (sel_i == 2) begin\n      out_o = in3_i;\n    end else if (sel_i == 3) begin\n      out_o = in4_i;\n    end else begin \n      out_o = 0;\n    end\n  end\n\nendmodule\n</code></pre> mux4_to_1_v3.v<pre><code>module mux4_to_1 #(\n  parameter Width = 32\n) (\n  input      [Width-1:0] in1_i,\n  input      [Width-1:0] in2_i,\n  input      [Width-1:0] in3_i,\n  input      [Width-1:0] in4_i,\n  input            [1:0] sel_i,\n  output reg [Width-1:0] out_o\n);\n\n  always @(in1_i, in2_i, in3_i, in4_i, sel_i) begin\n    case (sel_i)\n      2'd0    : out_o = in1_i;\n      2'd1    : out_o = in2_i;\n      2'd2    : out_o = in3_i;\n      2'd3    : out_o = in4_i;\n      default : out_o = 0;\n    endcase\n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/multiplicador/","title":"Multiplicadores","text":""},{"location":"documentacion/combinacionales/multiplicador/#1-codigos","title":"1. C\u00f3digos","text":"NormalCon registro mult.v<pre><code>// Fixed point multiplier A(a , b ) = A(10,21)\n//                        M(ap, bp) = M(21,42)\n//                        left_lim  = bp + a = 42 + 10 = 52\n//                        right_lim = bp - b = 42 - 21 = 21\n\nmodule mult #(\n   parameter Width = 32\n) (\n  input  signed [Width-1:0] a_i,\n  input  signed [Width-1:0] b_i,\n  output signed [Width-1:0] mult_o\n);\n\n  wire [Width*2-1:0] temp;\n\n  assign temp = a_i * b_i; \n  assign mult_o = temp[52:21];      \n\nendmodule\n</code></pre> mult_reg.v<pre><code>// Fixed point multiplier A(a , b ) = A(9,22)\n//                        M(ap, bp) = M(19,44)\n//                        left_lim  = bp + a = 44 + 9 = 53\n//                        right_lim = bp - b = 44 - 22 = 22\n\nmodule mult_reg #(\n   parameter Width = 32,\n   parameter Ent = 9,\n   parameter Frac = 22\n) (\n  input                         rst_i,\n  input                         clk_i,\n  input      signed [Width-1:0] a_i,\n  input      signed [Width-1:0] b_i,\n  output reg signed [Width-1:0] mult_o\n);\n\n  wire [Width*2-1:0] temp;\n  wire   [Width-1:0] mult_w;\n\n  assign temp = a_i * b_i; \n  assign mult_w = temp[Frac*2+Ent:Frac];\n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i) begin \n      mult_o &lt;= 0;\n    end else begin\n      mult_o &lt;= mult_w;\n    end\n  end  \n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/multiplicador/#2-verificacion","title":"2. Verificaci\u00f3n","text":"mult_tb.v<pre><code>`include \"mult.v\"\n\nmodule mult_tb #(\n  parameter Width = 32 \n) ();\n\n  // Definici\u00f3n de se\u00f1ales de entrada y salida\n  reg [Width-1:0] a;\n  reg [Width-1:0] b;\n\n  wire [Width-1:0] c;\n\n  // Instanciacion del modulo\n  mult #(Width) DUT (\n    .a_i(a),\n    .b_i(b),\n    .mult_o(c)\n  );\n\n  // Abrir archivo de salida\n  integer write_data;\n  localparam SF = 2.0**-21.0;\n  time t;\n\n  // Estimulo de las entradas\n  initial begin\n    write_data = $fopen(\"mult_tb_output.txt\",\"w\");\n    $dumpfile(\"mult_tb.vcd\");\n    $dumpvars(0,mult_tb);\n    $timeformat(-9, 2, \" ns\", 10);\n    a = 32'b00000000001000000000000000000000; //  1.0\n    b = 32'b00000000001000000000000000000000; //  1.0;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    a = 32'b00000000001100000000000000000000; //  1.5\n    b = 32'b00000000001100000000000000000000; //  1.5;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    a = 32'b00000000001100000000000000000000; //  1.5\n    b = 32'b11111111111100000000000000000000; // -0.5;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    // Cerrar archivo de salida\n    $fclose(write_data);\n\n    // Final de simulacion\n    $display(\"Test completed\");\n    //$display(\"a = %2d, b = %2d, result = %2d\", a, b, c);  \n\n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/restador/","title":"Restadores","text":""},{"location":"documentacion/combinacionales/restador/#1-codigos","title":"1. C\u00f3digos","text":"NormalCon registro sub.v<pre><code>module sub #(\n  parameter Width = 32\n) (\n  input  signed [Width-1:0] a_i,\n  input  signed [Width-1:0] b_i,\n  output signed [Width-1:0] sub_o\n);\n\n  assign sub_o = a_i - b_i;     \n\nendmodule\n</code></pre> sub_reg.v<pre><code>module sub_reg #(\n  parameter Width = 32\n) (\n  input                         rst_i,\n  input                         clk_i,\n  input      signed [Width-1:0] a_i,\n  input      signed [Width-1:0] b_i,\n  output reg signed [Width-1:0] sub_o\n);\n\n  wire [Width-1:0] sub_w;\n  assign sub_w = a_i - b_i; \n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i) begin \n      sub_o &lt;= 0;\n    end else begin\n      sub_o &lt;= sub_w;\n    end\n  end  \n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/restador/#2-verificacion","title":"2. Verificaci\u00f3n","text":"adder_tb.v<pre><code>`timescale 1ns / 100ps    \n`include \"sub.v\"\n\nmodule sub_tb #(\n  parameter Width = 32 \n) ();\n\n  // Definici\u00f3n de se\u00f1ales de entrada y salida\n  reg [Width-1:0] a;\n  reg [Width-1:0] b;\n\n  wire [Width-1:0] c;\n\n  // Instanciacion del modulo\n  sub #(Width) DUT (\n    .a_i(a),\n    .b_i(b),\n    .sub_o(c)\n  );\n\n  // Abrir archivo de salida\n  integer write_data;\n  localparam SF = 2.0**-21.0;\n  time t;\n\n  // Estimulo de las entradas\n  initial begin\n    write_data = $fopen(\"sub_tb_output.txt\",\"w\");\n    $dumpfile(\"sub_tb.vcd\");\n    $dumpvars(0,sub_tb);\n    $timeformat(-9, 2, \" ns\", 10);\n    a = 32'b00000000001000000000000000000000; //  1.0\n    b = 32'b00000000001000000000000000000000; //  1.0;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    a = 32'b00000000001100000000000000000000; //  1.5\n    b = 32'b00000000001100000000000000000000; //  1.5;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    a = 32'b00000000001100000000000000000000; //  1.5\n    b = 32'b11111111111100000000000000000000; // -0.5;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    // Cerrar archivo de salida\n    $fclose(write_data);\n\n    // Final de simulacion\n    $display(\"Test completed\");\n    //$display(\"a = %2d, b = %2d, result = %2d\", a, b, c);  \n\n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/sumador/","title":"Sumadores","text":""},{"location":"documentacion/combinacionales/sumador/#1-codigos","title":"1. C\u00f3digos","text":"NormalCon registro adder.v<pre><code>module adder #(\n  parameter Width = 32\n) (\n  input  signed [Width-1:0] a_i,\n  input  signed [Width-1:0] b_i,\n  output signed [Width-1:0] sum_o\n);\n\n  assign sum_o = a_i + b_i;\n\nendmodule\n</code></pre> adder_reg.v<pre><code>module adder_reg #(\n  parameter Width = 32\n) (\n  input                         rst_i,\n  input                         clk_i,\n  input      signed [Width-1:0] a_i,\n  input      signed [Width-1:0] b_i,\n  output reg signed [Width-1:0] sum_o\n);\n\n  wire [Width-1:0] sum_w;\n  assign sum_w = a_i + b_i;\n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i) begin \n      sum_o &lt;= 0;\n    end else begin\n      sum_o &lt;= sum_w;\n    end\n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/sumador/#2-verificacion","title":"2. Verificaci\u00f3n","text":"adder_tb.v<pre><code>`timescale 1ns / 100ps    \n`include \"adder.v\"\n\nmodule adder_tb #(\n  parameter Width = 32 \n) ();\n\n  // Definici\u00f3n de se\u00f1ales de entrada y salida\n  reg [Width-1:0] a;\n  reg [Width-1:0] b;\n\n  wire [Width-1:0] c;\n\n  // Instanciacion del modulo\n  adder #(Width) DUT (\n    .a_i(a),\n    .b_i(b),\n    .sum_o(c)\n  );\n\n  // Abrir archivo de salida\n  integer write_data;\n  localparam SF = 2.0**-21.0;\n  time t;\n\n  // Estimulo de las entradas\n  initial begin\n    write_data = $fopen(\"adder_tb_output.txt\",\"w\");\n    $dumpfile(\"adder_tb.vcd\");\n    $dumpvars(0,adder_tb);\n    $timeformat(-9, 2, \" ns\", 10);\n    a = 32'b00000000001000000000000000000000; //  1.0\n    b = 32'b00000000001000000000000000000000; //  1.0;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    a = 32'b00000000001100000000000000000000; //  1.5\n    b = 32'b00000000001100000000000000000000; //  1.5;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    a = 32'b00000000001100000000000000000000; //  1.5\n    b = 32'b11111111111100000000000000000000; // -0.5;\n    #100; t = $time;\n    $fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n\n    // Cerrar archivo de salida\n    $fclose(write_data);\n\n    // Final de simulacion\n    $display(\"Test completed\");\n    //$display(\"a = %2d, b = %2d, result = %2d\", a, b, c);  \n\n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/","title":"Secuencial","text":""},{"location":"documentacion/secuenciales/counter/","title":"Contadores","text":""},{"location":"documentacion/secuenciales/counter/#1-codigos","title":"1. C\u00f3digos","text":"counter.v<pre><code>module counter #(\n  parameter Width = 8\n) (\n  input              clk_i,\n  input              rst_i,\n  output             max_tick_i,\n  output [Width-1:0] q_o\n);\n\n  reg  [Width-1:0] reg_q;\n  wire [Width-1:0] sum_d;\n\n  assign sum_d = reg_q + 1;\n  assign max_tick_i = (reg_q == 2**Width-1) ? 1'b1 : 1'b0;\n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i) \n      reg_q &lt;= 0;\n    else \n      reg_q &lt;= sum_d;\n  end\n\n  assign q_o = reg_q;\n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/counter/#2-verificacion","title":"2. Verificaci\u00f3n","text":"counter_tb.v<pre><code>`timescale 1ns / 100 ps\n`include \"counter.v\"\n\nmodule counter_tb #(\n  parameter Width = 4\n)();\n  // Definici\u00f3n de se\u00f1ales de entrada y salida\n  reg clk;\n  reg rst;\n  wire max_tick;\n  wire [Width-1:0] q;\n\n  // Instanciacion del modulo\n  counter #(.Width(Width)) dut (\n    .clk_i(clk),\n    .rst_i(rst), \n    .max_tick_i(max_tick), \n    .q_o(q)\n  );\n\n  // Generador de reloj de 100 MHz con duty-cycle de 50 %\n  always #5 clk = ~clk;\n\n  // Secuancia de reset\n  initial begin\n    clk = 0; rst = 1; #10;\n             rst = 0; #10;\n  end\n\n  initial begin\n    // Configuracion de archivos de salida\n    $dumpfile(\"counter_tb.vcd\");\n    $dumpvars(0,counter_tb);\n\n    // Sincronizacion\n    #30;\n\n    //Estimulos de prueba\n    #300;\n\n    $display(\"Test completed\");\n    $finish;\n  end\n\nendmodule;\n</code></pre>"},{"location":"documentacion/secuenciales/flipflop/","title":"Flip-Flop","text":""},{"location":"documentacion/secuenciales/flipflop/#1-codigos","title":"1. C\u00f3digos","text":""},{"location":"documentacion/secuenciales/flipflop/#11-d-flip-flop-basico","title":"1.1. D Flip-Flop b\u00e1sico","text":"d_ff.v<pre><code>module d_ff (\n  input      clk_i,  \n  input      d_i,     \n  output reg q_o      \n);\n\n  always @(posedge clk_i) begin\n    q_o &lt;= d_i;     \n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/flipflop/#12-d-flip-flop-con-reset","title":"1.2. D Flip-Flop con reset","text":"Asincr\u00f3noS\u00edncrono d_ff_rst.v<pre><code>module d_ff_rst (\n  input      clk_i,  \n  input      rst_i, \n  input      d_i,     \n  output reg q_o      \n);\n\n  always @(posedge clk_i, posedge rst_i) begin   \n    if (rst_i)   \n      q_o &lt;= 1'b0;    \n    else \n      q_o &lt;= d_i;     \n  end\n\nendmodule\n</code></pre> d_ff_rst_sync.v<pre><code>module d_ff_rst_sync (\n  input      clk_i,  \n  input      rst_i, \n  input      d_i,     \n  output reg q_o      \n);\n\n  always @(posedge clk_i) begin   \n    if (rst_i)   \n      q_o &lt;= 1'b0;    \n    else \n      q_o &lt;= d_i;     \n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/flipflop/#13-d-flip-flop-con-reset-y-habilitacion","title":"1.3. D Flip-Flop con reset y habilitaci\u00f3n","text":"Asincr\u00f3noS\u00edncrono d_ff_rst_en.v<pre><code>module d_ff_rst_en (\n  input      clk_i,  \n  input      rst_i, \n  input      en_i,\n  input      d_i,     \n  output reg q_o      \n);\n\n  always @(posedge clk_i, posedge rst_i) begin   \n    if (rst_i)   \n      q_o &lt;= 1'b0;    \n    else if (en_i)\n      q_o &lt;= d_i;     \n  end\n\nendmodule\n</code></pre> d_ff_rst_en_sync.v<pre><code>module d_ff_rst_en_sync (\n  input      clk_i,  \n  input      rst_i, \n  input      en_i,\n  input      d_i,     \n  output reg q_o      \n);\n\n  always @(posedge clk_i) begin   \n    if (rst_i)   \n      q_o &lt;= 1'b0;    \n    else if (en_i)\n      q_o &lt;= d_i;     \n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/flipflop/#2-verificacion","title":"2. Verificaci\u00f3n","text":"<p>Proximamente ..</p>"},{"location":"documentacion/secuenciales/fsm_mealy/","title":"FSM Mealy","text":""},{"location":"documentacion/secuenciales/fsm_moore/","title":"FSM Moore","text":"template_moore.v<pre><code>module moore_regular_template\n#( parameter\n        param1 : &lt;value&gt;,\n        param2 : &lt;value&gt;\n)\n(\n    input wire clk, reset,\n    input wire [&lt;size&gt;] input1, input2, ...,\n    output reg [&lt;size&gt;] output1, output2\n); \n\nlocalparam [&lt;size_state&gt;] // for 4 states : size_state = 1:0\n    s0 = 0,\n    s1 = 1,\n    s2 = 2,\n    ... ;\n\n    reg[&lt;size_state&gt;] state_reg, state_next;  \n\n// state reg\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        state_reg &lt;= s1;\n    end\n    else begin\n        state_reg &lt;= state_next;\n    end\nend \n\n// next state logic :\nalways @(input1, input2, state_reg) begin \n    state_next = state_reg; // default state_next\n    case (state_reg)\n        s0 : begin\n            if (&lt;condition&gt;) begin  // if (input1 = 2'b01) then\n                state_next = s1; \n            end\n            else if (&lt;condition&gt;) begin  // add all the required conditionstion\n                state_next = ...; \n            end\n            else begin // remain in current state\n                state_next = s0; \n            end\n        end\n        s1 : begin\n            if (&lt;condition&gt;) begin // if (input1 = 2'b10) then\n                state_next = s2; \n            end\n            else if (&lt;condition&gt;) begin // add all the required conditionstions\n                state_next = ...; \n            end\n            else begin// remain in current state\n                state_next = s1; \n            end\n        end\n        s2 : begin\n            ...\n        end\n    endcase\nend \n\n// Moore output logic\nalways @(input1, input2, ..., state_reg) begin\n    // default outputs\n    output1 = &lt;value&gt;;\n    output2 = &lt;value&gt;;\n    ...\n    case (state_reg)  \n        s0 : begin\n            output1 = &lt;value&gt;;\n            output2 = &lt;value&gt;;\n            ...\n        end\n        s1 : begin\n            output1 = &lt;value&gt;;\n            output2 = &lt;value&gt;;\n            ...\n        end\n        s2 : begin\n            ...\n        end\n    endcase\nend \n\n\nendmodule\n</code></pre> template_moore_combined.v<pre><code>// moore_regular_template2.v\n\nmodule moore_regular_template2\n#( parameter\n        param1 : &lt;value&gt;,\n        param2 : &lt;value&gt;\n)\n(\n    input wire clk, reset,\n    input wire [&lt;size&gt;] input1, input2, ...,\n    output reg [&lt;size&gt;] output1, output2\n); \n\nlocalparam [&lt;size_state&gt;] // for 4 states : size_state = 1:0\n    s0 = 0,\n    s1 = 1,\n    s2 = 2,\n    ... ;\n\n    reg[&lt;size_state&gt;] state_reg, state_next;  \n\n\n// state register : state_reg\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        state_reg &lt;= s1;\n    end\n    else begin\n        state_reg &lt;= state_next;\n    end\nend \n\n// next state logic\n// Moore output logic\nalways @(input1, input2, state_reg) begin \n    state_next = state_reg; // default state_next\n    case (state_reg)\n        s0 : begin\n            output1 = &lt;value&gt;;\n            output2 = &lt;value&gt;;\n            ...\n            if (&lt;condition&gt;) begin  // if (input1 = 2'b01) then\n                state_next = s1; \n            end\n            else if (&lt;condition&gt;) begin  // add all the required conditionstion\n                state_next = ...; \n            end\n            else begin // remain in current state\n                state_next = s0; \n            end\n        end\n        s1 : begin\n            output1 = &lt;value&gt;;\n            output2 = &lt;value&gt;;\n            ...\n            if (&lt;condition&gt;) begin // if (input1 = 2'b10) then\n                state_next = s2; \n            end\n            else if (&lt;condition&gt;) begin // add all the required conditionstions\n                state_next = ...; \n            end\n            else begin// remain in current state\n                state_next = s1; \n            end\n        end\n        s2 : begin\n            ...\n        end\n    endcase\nend \n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/register/","title":"Registros","text":""},{"location":"documentacion/secuenciales/register/#1-codigos","title":"1. C\u00f3digos","text":""},{"location":"documentacion/secuenciales/register/#11-registro-basico-pipo","title":"1.1. Registro b\u00e1sico  (PIPO)","text":"Con habilitaci\u00f3nSin habilitaci\u00f3n reg_rst_en.v<pre><code>module reg_rst_en #(\n  parameter Width = 8\n) (\n  input                  clk_i,\n  input                  rst_i,\n  input                  en_i,\n  input      [Width-1:0] d_i,\n  output reg [Width-1:0] q_o\n);\n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i)\n      q_o &lt;= 0;\n    else if (en_i)\n      q_o &lt;= d_i;\n  end\n\nendmodule\n</code></pre> reg_rst.v<pre><code>module reg_rst #(\n  parameter Width = 8\n) (\n  input                  clk_i,\n  input                  rst_i,\n  input      [Width-1:0] d_i,\n  output reg [Width-1:0] q_o\n);\n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i)\n      q_o &lt;= 0;\n    else \n      q_o &lt;= d_i;\n  end\n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/register/#12-registro-de-corrimiento-serie-paralelo-sipo","title":"1.2. Registro de corrimiento Serie-Paralelo (SIPO)","text":"sipo_reg.v<pre><code>module sipo_reg #(\n  parameter Width = 8\n) (\n  input              clk_i,\n  input              rst_i,\n  input              d_i,  \n  input              en_i,\n  output [Width-1:0] q_o\n);  \n\n  reg  [Width-1:0] reg_q;\n  wire [Width-1:0] mux_d;\n\n  assign mux_d = (en_i) ? {reg_q[Width-2:0], d_i} : reg_q;\n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i)\n      reg_q &lt;= 0;\n    else\n      reg_q &lt;= mux_d;\n  end\n\n  assign q_o = reg_q;\n\nendmodule\n</code></pre>"},{"location":"documentacion/secuenciales/register/#13-registro-de-corrimiento-paralelo-serie-piso","title":"1.3. Registro de corrimiento Paralelo-Serie (PISO)","text":"piso_reg.v<pre><code>module piso_reg #(\n  parameter Width = 8   \n) (\n  input             rst_i,\n  input             clk_i,\n  input [Width-1:0] d_i,\n  input       [1:0] op_i,\n  output            q_o\n);  \n\n  reg [Width-1:0] mux_d, reg_q;\n\n  always @(d_i, op_i, reg_q) begin\n    case (op_i)\n      2'b00   : mux_d = reg_q;\n      2'b01   : mux_d = d_i;\n      2'b10   : mux_d = {reg_q[Width-2:0], 1'b0};\n      default : mux_d = 0;\n    endcase\n  end   \n\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i)\n      reg_q &lt;= 0;\n    else\n      reg_q &lt;= mux_d;    \n  end\n\n  assign q_o = reg_q[Width-1];\n\nendmodule\n</code></pre>"},{"location":"documentacion/teoria/","title":"Te\u00f3ria","text":""},{"location":"documentacion/teoria/fixed_point/","title":"03. Aritm\u00e9tica de punto fijo","text":""},{"location":"documentacion/teoria/fixed_point/#complemento-a-1","title":"Complemento a 1","text":"<p>El complemento a 1 consiste en invertir todos los 1s por 0s y todos los 0s por 1s de todo el n\u00famero binario. Ejemplo: \\(1010 1111\\) y su complemento a 1 es \\(01010000\\).</p>"},{"location":"documentacion/teoria/fixed_point/#complemento-a-2","title":"Complemento a 2","text":"<p>El complemento a 2 consiste en realizar el complemento a 1 y posteriormente sumar un 1. Ejemplo: \\(1010 1111\\) entonces su complemento a 2 se calcula primero ejecutando el complemento a 1, \\(0101 0000\\) y sumando un 1 al resultado anterior obtenemos \\(0101 0001\\)</p>"},{"location":"documentacion/teoria/fixed_point/#punto-fijo","title":"Punto Fijo","text":"<p>Un n\u00famero de punto fijo tiene la forma \\(A(a,b)\\) donde \\(a\\) es la parte entera, y \\(b\\)  es la parte fraccionaria. El n\u00famero de bits que tienen \\(A(a,b)\\) es \\(\\text{nbits} = a+b+1\\), de manera que es la suma de la parte entera m\u00e1s la parte fraccionaria m\u00e1s un bit de signo. El rango de n\u00fameros que se pueden representar es \\([-2^{a}, 2^{a} - 2^{-b}]\\). Esta representaci\u00f3n trabaja con una l\u00f3gica aritm\u00e9tica de complemento a 2.</p> N\u00famero Representaci\u00f3n Valor en decimal Rango Valor decimal sin signo <code>0000 1000</code> \\(A(3,4)\\) 0.5 \\([-8.0, 7.9375]\\) 8 <code>0000 1100</code> \\(A(3,4)\\) 0.75 \\([-8.0, 7.9375]\\) 12 <code>0111 0011</code> \\(A(3,4)\\) 7.1875 \\([-8.0, 7.9375]\\) 115 <code>1001 0000</code> \\(A(2,5)\\) -3.5 \\([-4.0,3.96875]\\) 144 <code>1001 0000</code> \\(A(3,4)\\) -7.0 \\([-8.0, 7.9375]\\) 144"},{"location":"documentacion/teoria/scm/","title":"03. SCM","text":""},{"location":"documentacion/teoria/scm/#single-constant-multiplication-scm","title":"Single constant multiplication (SCM)","text":""},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#1-introduccion","title":"1. Introducci\u00f3n","text":""},{"location":"getting_started/#11-que-es-verilog","title":"1.1. \u00bfQu\u00e9 es Verilog?","text":"<p>Verilog es un lenguaje de descripci\u00f3n de hardware o HDL (Hardware Description Language) que es utilizado para describir sistemas digitales como una memoria, un sumador, una ALU, un controlador o un microprocesador. Permite a los dise\u00f1adores dise\u00f1ar a varios niveles de abstracci\u00f3n. Es el HDL m\u00e1s utilizado y cuenta con una comunidad de usuarios de m\u00e1s de 50.000 dise\u00f1adores activos.</p>"},{"location":"getting_started/#12-plataformas","title":"1.2. Plataformas","text":"<p>Existen diversas plataformas para trabajar con Verilog, entre las m\u00e1s populares se encuentran:</p> <ul> <li>Aldec-HDL Student Edition</li> <li>Vivado ML Edition</li> <li>Intel Quartus Prime Lite Edition</li> <li>Icarus Verilog</li> </ul> <p>sin embargo, a pesar de que todas estas opciones cuentan con sus versiones gratuitas, no todas est\u00e1n disponibles en todos los sistemas operativos, en la siguiente tabla se muestran las diferentes compatibilidades:</p> Tabla 1. Compabilidad en diferentes sistemas operativos. Software Linux Windows Mac Aldec-HDL Student Edition \u2713 Vivado ML Edition \u2713 \u2713 Intel Quartus Prime Lite Edition \u2713 \u2713 Icarus Verilog \u2713 \u2713 \u2713 <p>por lo anterior, es buena idea comenzar a trabajar con Verilog utilizando Icarus Verilog, el cual es un compilador libre (open source) para el lenguaje de descripci\u00f3n de hardware IEEE-1364-2005 Verilog.</p> <p>A diferencia de las otras opciones los cuales cuentan con GUI (Graphical User Interface) y programas adicionales, Icarus Verilog funciona desde terminal y solo cuenta con herramientas necesarias para analizar, compilar y simular el c\u00f3digo Verilog.</p> <p>Las principales ventajas que cuenta esta herramienta sobre las otras son: </p> <ol> <li>Es muy ligera y f\u00e1cil de instalar.</li> <li>Es compatible con Linux, Windows y Mac.</li> <li>Su compilador es r\u00e1pido, muy robusto y estricto.</li> </ol> <p>El instalador del programa pesa aproximadamente 20MB y el programa instalado en disco utiliza 80MB. A diferencia de Aldec-HDL Student Edition el cual es muy permisivo con los errores en el c\u00f3digo, Icarus Verilog es muy estricto, lo que se traduce en un c\u00f3digo que tienes mayores posibilidades de ser sintetizado sin inconvenientes. </p> <p>La ventaja de instalar Vivado ML Edition o Intel Quartus Prime Lite Edition es que cuentan con todas las herramientas necesarias para llevar a cabo de manera completa el flujo de dise\u00f1o en FPGA. En el siguiente diagrama se muestra el flujo de dise\u00f1o en FPGA<sup>1</sup>:</p> <p><pre><code>%%{ \n  init : { \n    \"theme\" : \"default\", \n    \"flowchart\" : { \n      \"curve\" : \n    }\n  }\n}%%\ngraph LR\n  A[Especificaciones] --&gt; B[HDL];\n  B --&gt; C[S\u00edntesis];\n  C --&gt; D[Place and Route];\n  D --&gt; E[Verificaci\u00f3n del circuito];\n  B -.-&gt; F[Simulaci\u00f3n];\n  D -.-&gt; G[An\u00e1lisis de tiempo est\u00e1tico];</code></pre> Una de las estrategias m\u00e1s comunes al trabajar con Verilog es primero compilar y simular el c\u00f3digo en Icarus Verilog y una vez probado pasar a Vivado ML Edition o Intel Quartus Prime Lite Edition para realizar la s\u00edntesis, el place and route y generar el archivo de programaci\u00f3n para la FPGA. La ventaja de hacerlo de esta manera es que la compilaci\u00f3n y la simulaci\u00f3n es m\u00e1s r\u00e1pida en Icarus Verilog, lo que se traduce en un ahorro en el tiempo de dise\u00f1o.</p> <p>Para poder visualizar las formas de onda generadas por Icarus Verilog se utiliza el programa GTKWave el cual es un completo visor de ondas basado en GTK+ para Unix, Win32 y Mac OSX que lee archivos LXT, LXT2, VZT, FST y GHW, as\u00ed como archivos est\u00e1ndar Verilog VCD/EVCD y permite su visualizaci\u00f3n.</p>"},{"location":"getting_started/#2-instalacion-de-icarus","title":"2. Instalaci\u00f3n de Icarus","text":""},{"location":"getting_started/#21-windows","title":"2.1. Windows","text":"<p>La manera recomendada para realizar la instalaci\u00f3n en Windows es utilizando Scoop, un instalador de l\u00ednea de comandos dise\u00f1ado espec\u00edficamente para Windows. A continuaci\u00f3n se muestran los pasos para instalar Scoop e Icarus Verilog.</p> Nota 1. <p>Se sugiere visitar la p\u00e1gina oficial de Scoop para verificar si ha habido cambios en los comandos de instalaci\u00f3n. La informaci\u00f3n fue revisada por \u00faltima vez el 29/07/2023.</p> Nota 2. <p>Si se instala Icarus Verilog de manera manual es necesario agregar la carpeta de instalaci\u00f3n al <code>PATH</code>.</p> <ol> <li>Abrir una terminal de PowerShell  o Windows PowerShell y ejecutar las siguientes dos lineas de comando para instalar Scoop : <pre><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUse\nirm get.scoop.sh | iex\n</code></pre></li> <li>Una vez instalado, ejecutar el comando siguiente comando para verificar que la instalaci\u00f3n fue exitosa: <pre><code>scoop --version\n</code></pre></li> <li>Ejecutar el siguiente comando para instalar Icarus Verilog: <pre><code>scoop install iverilog\n</code></pre></li> <li>Verificar que la instalaci\u00f3n fue exitosa ejecutando los siguientes comandos: <pre><code>scoop list\niverilog\n</code></pre></li> <li>En Windows, al instalar Icarus Verilog se incluye preinstalado el visor de formas de ondas GTKWave, para verificar que funciona correctamente, ejecuta el siguiente comando: <pre><code>gtkwave --version\ngtkwave\n</code></pre></li> </ol>"},{"location":"getting_started/#22-linux","title":"2.2. Linux","text":"<p>Para sistemas operativos Linux basados en Debian/Ubuntu la instalaci\u00f3n m\u00e1s sencilla. Seguir los siguientes pasos:</p> <ol> <li> <p>Abrir una terminal  y ejecutar el siguiente comando para instalar Icarus Verilog y GTKWave: <pre><code>sudo apt install iverilog gtkwave\n</code></pre></p> </li> <li> <p>Verificar que la instalaci\u00f3n fue exitosa ejecutando los siguientes comandos: <pre><code>iverilog\ngtkwave --version\ngtkwave\n</code></pre></p> </li> </ol>"},{"location":"getting_started/#23-mac","title":"2.3. Mac","text":"<p>La manera recomendada para realizar la instalaci\u00f3n en macOS es utilizando el gestor de paquetes Homebrew. A continuaci\u00f3n se muestran los pasos para instalar Homebrew e Icarus Verilog<sup>2</sup> .</p> Nota 3. <p>Se sugiere visitar la p\u00e1gina oficial de Homebrew para verificar si ha habido cambios en los comandos de instalaci\u00f3n. La informaci\u00f3n fue revisada por \u00faltima vez el 29/07/2023.</p> <ol> <li>Abrir una terminal y ejecutar el siguiente comando para instalar Homebrew: <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></li> <li>Ejecutar el siguiente comando para instalar Icarus Verilog: <pre><code>brew install icarus-verilog\n</code></pre></li> <li>Descargar desde la p\u00e1gina oficial GTKWave para obtener la \u00faltima versi\u00f3n, es un archivo <code>.zip</code>, descomprimirlo y darle el acceso requerido. Alternativamente ejecutar el siguiente comando, la versi\u00f3n pude ser m\u00e1s vieja: <pre><code>brew install --cask gtkwave\n</code></pre></li> <li>Verificar que la instalaci\u00f3n fue exitosa ejecutando los siguientes comandos: <pre><code>iverilog\ngtkwave --version\ngtkwave\n</code></pre></li> </ol>"},{"location":"getting_started/#3-como-utilizar-icarus","title":"3. \u00bfC\u00f3mo utilizar Icarus?","text":"<p>Para aprender a utilizar Icarus Verilog y GTKWave consideremos el siguiente circuito combinacional, que esta definido por la siguiente ecuaci\u00f3n booleana:</p> \\[ f(A,B,C) = (\\overline{A} \\cdot C) + (B \\cdot C) \\] <p>y cuya tabla de verdad es la siguiente:</p> Tabla 2. Tabla de verdad de funci\u00f3n boolena. Decimal \\(A\\) \\(B\\) \\(C\\) \\(f(A,B,C)\\) 0 0 0 0 0 1 0 0 1 1 2 0 1 0 0 3 0 1 1 1 4 1 0 0 0 5 1 0 1 0 6 1 1 0 0 7 1 1 1 1"},{"location":"getting_started/#31-descripcion-en-verilog","title":"3.1. Descripci\u00f3n en Verilog","text":"<p>El c\u00f3digo en Verilog que describe el circuito combinacional de arriba es el siguiente: </p> lut.v<pre><code>module lut(\n  input A,\n  input B,\n  input C,\n  output F\n);\n\n  assign F = (~A &amp; C) | (B &amp; C);\n\nendmodule\n</code></pre>"},{"location":"getting_started/#32-simulacion","title":"3.2. Simulaci\u00f3n","text":"<p>En el siguiente c\u00f3digo se muestra una plantilla sencilla para hacer un testbench combinacional, este cuenta con comentarios que explican cada una de las l\u00edneas:</p> lut.v<pre><code>`timescale 1ns / 100 ps\n`include \"lut.v\"\n\nmodule lut_tb();\n  // Definicion de senales de entrada y salida\n  reg A;\n  reg B;\n  reg C;\n  wire F;\n\n  // Instanciacion del modulo\n  lut dut(.A(A), .B(B), .C(C), .F(F));\n\n  // Variables para archivo, iteraciones y tiempo\n  integer write_data;\n  integer i;\n  time t;\n\n  initial begin\n    // Configuracion de archivos de salida\n    write_data = $fopen(\"lut_tb_output.txt\",\"w\");\n\n    // Salida de simulacion y variables de salida\n    $dumpfile(\"lut_tb.vcd\");\n    $dumpvars(0,lut_tb);\n\n    // Configuracion de formato de tiempo\n    $timeformat(-9, 2, \" ns\", 10);\n\n    // Simular todas las combinaciones posibles\n    for (i = 0; i &lt; 8; i = i + 1) begin\n        {A,B,C} = i; #20; t = $time;\n        $fdisplay(write_data,\"Time = %t, {A,B,C} = %b, X = %b\", t, {A,B,C}, F);\n    end\n\n    // Cerrar archivo de texto\n    $fclose(write_data);\n\n    // Terminar simulacion\n    $display(\"Test completed\");\n    $finish;\n\n  end\n\nendmodule\n</code></pre> <p>Para realizar la simulaci\u00f3n es necesario seguir los siguientes pasos:</p> <ol> <li>Crear una nueva carpera para el proyecto, para este ejemplo nombrar a la carpeta <code>test</code>.</li> <li>Copiar dentro de ella los archivos:<ul> <li><code>lut.v</code></li> <li><code>lut_tb.v</code></li> </ul> </li> <li>Abrir una terminal y ejecutar el siguiente comando para compilar: <pre><code>iverilog -o lut_tb.vvp lut_tb.v\n</code></pre></li> <li>Ejecutar el siguiente comando para ejecutar el archivo compilado: <pre><code>vvp lut_tb.vvp\n</code></pre></li> <li>Abrir el programa GTKWave para analizar la simulaci\u00f3n con el siguiente comando: <pre><code>start gtkwave lut_tb.vcd\n</code></pre></li> <li>Dentro de GTKWave desplegar <code>lut_tb</code>, despu\u00e9s dar clic en <code>dut</code> y en la secci\u00f3n <code>Signals</code> seleccionar las se\u00f1ales <code>A</code>, <code>B</code>, <code>C</code> y <code>F</code>, manteniendo presionada la tecla Ctrl y seleccionando con el Left Button del mouse.</li> </ol> Nota 4. <p>Para aprender a automatizar este proceso utilizando un script escrito en lenguaje bash ver la secci\u00f3n Scrits.</p>"},{"location":"getting_started/#33-resultados","title":"3.3. Resultados","text":"<p>Dentro de la carpeta se generar\u00e1 un archivo con el nombre <code>lut_tb_output.txt</code> que contiene lo siguiente:</p> lut_tb_output.txt<pre><code>Time =   20.00 ns, {A,B,C} = 000, X = 0\nTime =   40.00 ns, {A,B,C} = 001, X = 1\nTime =   60.00 ns, {A,B,C} = 010, X = 0\nTime =   80.00 ns, {A,B,C} = 011, X = 1\nTime =  100.00 ns, {A,B,C} = 100, X = 0\nTime =  120.00 ns, {A,B,C} = 101, X = 0\nTime =  140.00 ns, {A,B,C} = 110, X = 0\nTime =  160.00 ns, {A,B,C} = 111, X = 1\n</code></pre> <p>y la forma de onda debe ser igual a la mostrada en la siguiente imagen:</p> <p> </p> Figura 1. Resultados de simulaci\u00f3n en GTKWave."},{"location":"getting_started/#4-referencias","title":"4. Referencias","text":"<ol> <li> <p>\u201cFPGA vs. ASIC Design Flow\u201d, Xilinx. https://www.xilinx.com/video/fpga/fpga-vs-asic-design-flow.html (consultado el 29 de julio de 2023).\u00a0\u21a9</p> </li> <li> <p>S. Ankit, \u201cHow to simulate Verilog models on macOS\u201d, Medium, el 18 de septiembre de 2020. https://saiankit.medium.com/how-to-simulate-verilog-models-on-macos-5a6f821b2c4f (consultado el 31 de julio de 2023).\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/acronyms/","title":"Acr\u00f3nimos","text":"<ol> <li>ISA - Instruction Set Architecture</li> <li>ASSAP - Application-Specific Standard Product</li> <li>ASIC - Application-Specific Integrated Circuit</li> <li>SRAM - Static Random Access Memory</li> <li>LEs - Logic Elements</li> <li>IP - Intelectual Property</li> <li>PCI - Peripheral Component Interconnect</li> <li>SoC - System On Chip</li> <li>TCO - Total Cost Ownership</li> <li>PROM - Programmable Read Only Memory </li> <li>EPROM - Eraseable Programmable Read Only Memory </li> <li>PLAs - Programmable Logic Arrays</li> <li>PALs - Programmable Array Logic</li> <li>CPLDs -  Complex Programmable Logic Device</li> <li>CLBs - Configurable Logic Blocks</li> <li>LUTs - Look Up Tables</li> <li>PLDs - Programmable Logic Devices</li> <li>FPGA - Field Programmable Gate Array</li> <li>RTL - Register Transfer Logic</li> <li> <p>ALM - Adaptive Logic Module</p> </li> <li> <p>ALU - Arithmetic Logic Unit</p> </li> <li>HDL - Hardware Description Language</li> <li>GUI - Graphical User Interface</li> </ol>"},{"location":"getting_started/bibliography/","title":"Bibliograf\u00eda","text":""},{"location":"getting_started/bibliography/#1-verilog","title":"1. Verilog","text":"<ol> <li>S. D. Brown y Z. G. Vranesic, Fundamentals of digital logic with Verilog design, Third edition. New York: McGraw-Hill Higher Education, 2014.</li> <li>Pong P. Chu, FPGA Prototyping by Verilog Examples Xilinx Spartan-3 Version, Wiley &amp; Sons, Incorporated, John, 2008.</li> <li>S. Palnitkar, Verilog HDL: A Guide to Digital Design and Synthesis, Prentice-Hall, Inc, 1996.</li> <li>\u201cIEEE Standard for Verilog Hardware Description Language\u201d, IEEE Std 1364-2005 (Revision of IEEE Std 1364-2001), pp. 1\u2013590, abr. 2006, doi: 10.1109/IEEESTD.2006.99495.</li> </ol>"},{"location":"getting_started/bibliography/#2-vhdl","title":"2. VHDL","text":"<ol> <li>Pong P. Chu, FPGA Prototyping by VHDL Examples Xilinx Spartan-3 Version, Wiley &amp; Sons, Incorporated, John, 2008.</li> </ol>"},{"location":"getting_started/bibliography/#3-fpga","title":"3. FPGA","text":"<ol> <li>A. Moore, \u201cFPGAs For Dummies, Altera Special Edition\u201d, 2014.</li> </ol>"},{"location":"getting_started/code_guidelines/","title":"Code Guidelines","text":""},{"location":"getting_started/code_guidelines/#1-objetivos","title":"1. Objetivos","text":"<p>Esta gu\u00eda de estilo de codificaci\u00f3n esta basada en lowRISC Verilog Coding Style Guide<sup>1</sup>. Esta gu\u00eda tiene como objetivos:</p> <ul> <li>Promover la coherencia entre los proyectos de desarrollo de hardware.</li> <li>Aumentar la legibilidad del c\u00f3digo.</li> <li>Promover las mejores pr\u00e1cticas.</li> <li>Aumentar el intercambio y la reutilizaci\u00f3n de c\u00f3digo.</li> <li>Disminuir los errores de codificaci\u00f3n.</li> </ul>"},{"location":"getting_started/code_guidelines/#2-reglas","title":"2. Reglas","text":"<p>No tabuladores</p> <p>No utilice tabuladores en ning\u00fan sitio. Utilizar espacios para sangrar o alinear el texto.</p> <p>Sin espacios finales</p> <p>Elimina los espacios en blanco al final de las l\u00edneas.</p> <p>Usar <code>begin</code> y <code>end</code> a menos que toda la declaraci\u00f3n quepa en una sola l\u00ednea.</p> <p>S\u00f3lo se puede omitir <code>begin</code> y <code>end</code> si toda una sentencia terminada en punto y coma cabe en una sola l\u00ednea.</p> <pre><code>if (condition) begin\n  foo = bar;\nend else begin\n  foo = bum;\nend\n</code></pre> <p>La sangr\u00eda es de dos espacios por nivel.</p> <p>Utilice espacios para la sangr\u00eda. No utilice tabuladores. Debe configurar su editor para que emita espacios cuando pulse la tecla de tabulaci\u00f3n.</p> <p>Listas delimitadas por comas</p> <p>Para varios elementos en una l\u00ednea, un espacio debe separar la coma y el car\u00e1cter siguiente.</p> <p>Alineaci\u00f3n tabular</p> <p>En general, se fomenta el uso de la alineaci\u00f3n tabular.</p> <pre><code>logic [7:0]  my_interface_data;\nlogic [15:0] my_interface_address;\nlogic        my_interface_enable;\nlogic        another_signal;\nlogic [7:0]  something_else;\n</code></pre> <p>Comentarios</p> <p>Se prefieren los comentarios estilo C++ (<code>//</code> foo). Tambi\u00e9n se pueden utilizar comentarios de estilo C (<code>/\\* bar \\*/</code>).</p>"},{"location":"getting_started/code_guidelines/#3-plantilla-basica","title":"3. Plantilla b\u00e1sica","text":"<pre><code>// Author: Some Name\n// Name: my_module.v\n// \n// Description: Amazing code description\n\nmodule my_module #(\n  parameter Width = 80,\n  parameter Height = 24\n) (\n  input              clk_i,\n  input              rst_ni,\n  input              req_valid_i,\n  input  [Width-1:0] req_data_i,\n  output             req_ready_o,\n  ...\n);\n\n  logic [Width-1:0] req_data_masked;\n\n  submodule u_submodule (\n    .clk_i,\n    .rst_ni,\n    .req_valid_i,\n    .req_data_i (req_data_masked),\n    .req_ready_o(req_ready),\n    ...\n  );\n\n  always_comb begin\n    req_data_masked = req_data_i;\n    case (fsm_state_q)\n      ST_IDLE: begin\n        req_data_masked = req_data_i &amp; MASK_IDLE;\n        ...\n  end\n\n  ...\n\nendmodule\n</code></pre>"},{"location":"getting_started/code_guidelines/#4-referencias","title":"4. Referencias","text":"<ol> <li> <p>\u201cstyle-guides/VerilogCodingStyle.md at master \u00b7 lowRISC/style-guides\u201d. https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md (consultado el 20 de agosto de 2023).\u00a0\u21a9</p> </li> <li> <p>\u201cGoogle C++ Style Guide\u201d. https://google.github.io/styleguide/cppguide.html (consultado el 29 de agosto de 2023).\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/extra/","title":"Extra","text":"<pre><code>%%{ \n  init : { \n    \"theme\" : \"default\", \n    \"flowchart\" : { \n      \"curve\" : \"linear\" \n    }\n  }\n}%%\ngraph TB\n  A[Digital Logic];\n  B[Standard Logic];\n  C[Programable Logic];\n  D[ASICs];\n  E[Full Custom];\n\n  F[\"TTL \n     74xx\"];\n  G[\"CMOS\n     4xxx\"];\n\n  H[PLDs];\n  I[FPGAs];\n  J[CPLDs];\n\n  K[\"Gate \n     Arrays\"];\n  L[\"Standard \n     Cell\"];\n\n  M[\"Microprocessor\n     &amp; ARM\"];\n\n\n  A --&gt; B;\n  A --&gt; C;\n  A --&gt; D;\n  A --&gt; E;\n\n  B --&gt; F;\n  B --&gt; G;\n\n  C --&gt; H;\n  C --&gt; I;\n  C --&gt; J;\n\n  D --&gt; K;\n  D --&gt; L;\n\n  E --&gt; M;</code></pre> <pre><code>%%{ \n  init : { \n    \"theme\" : \"default\", \n    \"flowchart\" : { \n      \"curve\" : \"linear\" \n    }\n  }\n}%%\ngraph LR\n  A[\"Design Entry:\n     Schematic or \n     HDL\"];\n  B[\"Functional \n     Simulation\"];\n  C[\"Synthesis or\n     Mapping\"];\n  D[\"Place and Route\n     or Fitting\"];\n  E[\"Simulation\"];\n  F[\"Programming\"];\n  G[\"Test and \n      Integration\"];\n  H[\"Release\"];\n\n  A --&gt; B;\n  B --&gt; C;\n\n  B --&gt; A;\n\n  C --&gt; D;\n  D --&gt; E;\n  E --&gt; F;\n\n  E --&gt; B;\n\n  F --&gt; G;\n\n  G --&gt; E;\n\n  G --&gt; H; </code></pre>"},{"location":"getting_started/extra/#quartus-prime","title":"Quartus Prime","text":""},{"location":"getting_started/extra/#design-entry","title":"Design Entry","text":"<ul> <li>Schematic Capture</li> <li>Import of IP blocks</li> <li>HDL text entry, including VHDL, Verilog, and System Verilg</li> <li>State machine entry</li> <li>Import of EDIF files</li> </ul>"},{"location":"getting_started/extra/#design-analysis-ans-synthesis","title":"Design Analysis ans Synthesis","text":"<ul> <li>Checks the design source files for errors</li> <li>Builds a database</li> <li>Synthesizes and optimizes the logic design</li> <li>Maps the design logic to device resources</li> </ul>"},{"location":"getting_started/extra/#design-fitting","title":"Design Fitting","text":"<ul> <li>Balanced</li> <li>High Perfomance (Speed)</li> <li>Low Power</li> <li>Small Area</li> </ul>"},{"location":"getting_started/extra/#design-analysis-in-picture","title":"Design Analysis in Picture","text":"<ul> <li>RTL Viewer</li> <li>Technology Map Viewer</li> <li>Chip Planner</li> </ul>"},{"location":"getting_started/extra/#simulation","title":"Simulation","text":"<ul> <li>Static Timing Analysis</li> <li>TimeQuest timing analyzer<ul> <li>Calculate slack</li> <li>Determine Fmax</li> </ul> </li> <li>ModelSim</li> </ul>"},{"location":"getting_started/fpgas/","title":"FPGA","text":""},{"location":"getting_started/fpgas/#1-que-es-una-fpga","title":"1. \u00bfQu\u00e9 es una FPGA?","text":"<p>Las FPGAs (Field Programmable Gate Arrays) son circuitos integrados que permiten a los dise\u00f1adores programar l\u00f3gica digital personalizada en el que la funci\u00f3n puede definirse despu\u00e9s de la fabricaci\u00f3n. Una FPGA permite programar caracter\u00edsticas y funciones de productos, adaptarse a nuevos est\u00e1ndares y reconfigurar el hardware para aplicaciones espec\u00edficas incluso despu\u00e9s de instalar el producto sobre el campo, de ah\u00ed el t\u00e9rmino programable sobre el campo. Y las matrices de compuertas son matrices bidimensionales de compuertas l\u00f3gicas. Si se juntan suficientes de estas cosas, se puede hacer que esos c\u00e1lculos simples se sumen para hacer algo significativo.</p>"},{"location":"getting_started/fpgas/#2-que-fpga-elegir","title":"2. \u00bfQu\u00e9 FPGA elegir?","text":"<p>En el mundo, existen cuatro destacadas compa\u00f1\u00edas fabricantes de FPGAs: AMD (Xilinx), Intel (Altera), Lattice y Microchip. La cuota de mercado para el a\u00f1o 2021 se refleja en la siguiente gr\u00e1fica:</p> <p> </p> Figura 1. Cuota de mercado de fabricantes de FPGA 2021. <p>AMD (Xilinx) domina casi la mitad del mercado con una participaci\u00f3n del 51%, seguida por Intel (Altera), que cuenta con el 29%, Lattice con un 7%, Microchip con un 6%. El 7% restante se reparten Otros competidores. <sup>1</sup></p> <p>Debido a lo anterior es buena idea centrarse en aprender a utilizar FPGAs de XIlinx o de Altera. En la siguiente tabla se muestran algunas FPGAs que han tenido buena recepci\u00f3n en el mercado y las cuales se encuentran en la mayor\u00eda de laboratorios de dise\u00f1o digital.</p> Tabla 1. FPGAs recomendadas. FPGA Logic Elementes Clock Source SoC/HPS Empresa Precio Basys 3 Digilent 33,280 100 MHz Digilent $165.00 Nexys A7 Digilent 101,440 100 MHz Digilent $349.00 ZedBoard Zynq-7000 Digilent 85K 100 MHz \u2713 Digilent $589.00 DE10-Nano Kit Terasic 110K 50 MHz \u2713 Terasic $225.00 DE1-SoC Board 85K 50 MHz \u2713 Terasic $377.00 DE10-Standard Terasic 110K 50 MHz \u2713 Terasic $499.00"},{"location":"getting_started/fpgas/#3-referencias","title":"3. Referencias","text":"<ol> <li> <p>drex, \u201cLattice Avant of Mid-Range FPGAs May Be the Biggest Winner\u201d, DRex Electronics, el 7 de febrero de 2023. https://www.icdrex.com/lattice-avant-of-mid-range-fpgas-may-be-the-biggest-winner/ (consultado el 05 de agosto de 2023).\u00a0\u21a9</p> </li> <li> <p>\u201cFPGA Insights and Trends 2023: Unleashing the Power of FPGA\u201d, Design And Reuse. https://www.design-reuse.com/industryexpertblogs/54476/fpga-insights-and-trends-2023-unleashing-the-power-of-fpga.html (consultado el 06 de agosto de 2023).\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/scripts/","title":"Scripts","text":""},{"location":"getting_started/scripts/#1-automatizar-icarus-verilog","title":"1. Automatizar Icarus Verilog","text":"<p>Considere que se tienen dos archivos, uno llamado <code>mymodule.v</code>, el cual contiene un dise\u00f1o en Verilog y otro llamado <code>mymodule_tb.v</code>, el cual se utiliza para simular el dise\u00f1o. El flujo de trabajo en Icarus Verilog consiste en los siguientes pasos:</p> <ol> <li>Editar el m\u00f3dulo principal o el archivo de simulaci\u00f3n.</li> <li>Compilar el c\u00f3digo con el comando: <pre><code>iverilog -o mymodule_tb.vvp mymodule_tb.v\n</code></pre></li> <li>Ejecutar el c\u00f3digo compilado con el comando: <pre><code>vvp mymodule.vvp\n</code></pre></li> <li>Abrir GTKWave con el comando: <pre><code>start gtkwave mymodule.vcd\n</code></pre></li> <li>Insertar todas las se\u00f1ales necesarios en la simulaci\u00f3n y analizar su comportamiento.</li> </ol> <p>El problema con la metodolog\u00eda anterior es que se necesitan realizar muchos pasos cada vez que se hace una peque\u00f1a modificaci\u00f3n a los archivos <code>.v</code>. </p> <p>Una manera para solventar esta problem\u00e1tica es guardar la simulaci\u00f3n generada en GTKWave con la extensi\u00f3n <code>.gtkw</code>, despu\u00e9s abrirla y recargar el archivo <code>.vcd</code>. No obstante a\u00fan es necesario compilar y ejecutar nuevamente el c\u00f3digo cada vez que se realice un cambio.</p> <p>Para que este proceso repetitivo sea m\u00e1s sencillo se puede utilizar un script escrito en bash para reducir todo este proceso a una sola l\u00ednea de comando. En la siguiente tabla se muestran los scripts para cada sistema operativo:</p> Tabla 1. Scripts para automatizar compilaci\u00f3n, ejecuci\u00f3n y visualizador para Icarus Verilog y GTKWave escrito en lenguaje bash. Plataforma Enlace Probada Windows simu_wind.sh \u2713 Linux simu_linux.sh \u2713 Mac simu_mac.sh \u2713"},{"location":"getting_started/scripts/#2-consideraciones-por-sistema-operativo","title":"2. Consideraciones por sistema operativo","text":""},{"location":"getting_started/scripts/#21-windows","title":"2.1. Windows","text":"<p>Para utilizarlo en Windows es necesario tener instalado Git Bash, este programa adem\u00e1s de permitirnos utilizar el control de versiones de Git incluye una terminal que deja al usuario ejecutar algunos comandos Linux dentro de Windows.</p> <p>Comandos: <pre><code>./simu_wind.sh mymodule_tb\n./simu_wind.sh mymodule_tb -v\n</code></pre></p>"},{"location":"getting_started/scripts/#21-linux","title":"2.1. Linux","text":"<p>La primera vez puede requerir cambiar los permisos de ejecuci\u00f3n del archivo con el comando: <pre><code>chmod +x simu_linux.sh\n</code></pre> Comandos: <pre><code>./simu_linux.sh mymodule_tb\n./simu_linux.sh mymodule_tb -v\n</code></pre></p>"},{"location":"getting_started/scripts/#23-mac","title":"2.3. Mac","text":"<p>Comandos: <pre><code>source simu_mac.sh mymodule_tb\nsource simu_mac.sh mymodule_tb -v\n</code></pre></p>"},{"location":"getting_started/scripts/#2-ejemplo-de-uso-del-script","title":"2. Ejemplo de uso del script","text":"<p>Para compilar y ejecutar el testbench y  abrir el visualizador de onda se utiliza el siguiente comando: <pre><code>./simu_wind.sh mymodule_tb\n</code></pre> no se requiere especificar la extensi\u00f3n.</p> <p>Una vez ejecutado el comando se desplegar\u00e1 una consola de Git Bash con la siguiente informaci\u00f3n: <pre><code>1. Compiling verilog code...\n2. Runing simulation...\nVCD info: dumpfile mymodule_tb.vcd opened for output.\nTest completed\nmymodule_tb.v:46: $finish called at xxxx (xxps)\n3. Opening wave viewer..\nIt took 0.223 seconds.\nPress enter to continue\n</code></pre></p>"},{"location":"getting_started/scripts/#21-uso-de-banderas","title":"2.1. Uso de banderas","text":"<p>Para solo compilar se le a\u00f1ade al comando la bandera <code>-c</code> de la siguiente manera: <pre><code>./simu_wind.sh mymodule_tb -c\n</code></pre></p> <p>Para solo ejecutar el archivo compilado se le a\u00f1ade al comando la bandera <code>-r</code> de la siguiente manera: <pre><code>./simu_wind.sh mymodule_tb -r\n</code></pre></p> <p>Se pueden combinar las banderas para hacer dos cosas al mismo tiempo de la siguiente manera: <pre><code>./simu_wind.sh mymodule_tb -c -r\n</code></pre></p> <p>Para solo abrir el visualizador de forma de onda se le a\u00f1ade al comando la bandera <code>-v</code> de la siguiente manera: <pre><code>./simu_wind.sh mymodule_tb -v\n</code></pre></p>"},{"location":"getting_started/scripts/#22-manejo-de-errores","title":"2.2. Manejo de errores","text":"<p>Si se ingresa una bandera equivocada al programa, no se ingresa el nombre del archivo o el archivo no existe se desplegar\u00e1 un mensaje de error como el siguiente: <pre><code>You must specify the file name.\nUse: simu_wind.sh &lt;file&gt; [options]\nOptions:\n  none: Compile, simulate and open viewer.\n    -c: Just compile code.\n    -r: Just run simulation.\n    -v: Just open wave viewer.\nIt is possible to use more than one option at the same time.\nPress enter to continue\n</code></pre></p>"},{"location":"getting_started/scripts/#3-referencias","title":"3. Referencias","text":"<ol> <li> <p>\u201cBash Scripting Tutorial \u2013 Linux Shell Script and Command Line for Beginners\u201d, freeCodeCamp.org, el 20 de marzo de 2023.https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/ (consultado el 05 de agosto de 2023).\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/verilog_reference/","title":"Verilog Reference","text":"<p>Este es un resumen de fundamentos b\u00e1sicos de Verilog extra\u00eddo de los libros <sup>1</sup> <sup>2</sup> <sup>3</sup>.</p>"},{"location":"getting_started/verilog_reference/#1-elementos-lexicos","title":"1. Elementos l\u00e9xicos","text":""},{"location":"getting_started/verilog_reference/#11-lenguage-sensible-a-mayusculas-y-minusculas","title":"1.1. Lenguage sensible a may\u00fasculas y min\u00fasculas","text":"<p>Verilog es un lenguaje que distingue entre may\u00fasculas y min\u00fasculas. As\u00ed que, <code>data-bus</code>, <code>Data-bus</code> y <code>DATAEUS</code> se refieren a tres objetos diferentes.</p>"},{"location":"getting_started/verilog_reference/#12-comentarios","title":"1.2. Comentarios","text":"<p>Los comentarios cortos empiezan con <code>//</code> y contin\u00faan hasta el final de la l\u00ednea. Los comentarios largos empiezan con <code>/*</code> y terminan con <code>*/</code>.</p>"},{"location":"getting_started/verilog_reference/#13-espacios-en-blanco","title":"1.3. Espacios en blanco","text":"<p>Los espacios en blanco incluyen los caracteres espacio, tabulador y nueva l\u00ednea, se utilizan para separar identificadores y pueden utilizarse libremente en el c\u00f3digo Verilog. Podemos utilizar espacios en blanco adecuados para dar formato al c\u00f3digo y hacerlo m\u00e1s legible.</p>"},{"location":"getting_started/verilog_reference/#2-tipos-de-datos","title":"2. Tipos de datos","text":""},{"location":"getting_started/verilog_reference/#21-sistema-de-cuatro-valores","title":"2.1. Sistema de cuatro valores","text":"<p>En la mayor\u00eda de los casos se utilizan cuatro valores b\u00e1sicos:</p> Tabla 1. Conjunto de valores. Valor Descripci\u00f3n 0 valor l\u00f3gico 0 1 valor l\u00f3gico 1 z triestado (alta impedancia) x valor desconocido"},{"location":"getting_started/verilog_reference/#22-grupos-de-tipos-de-datos","title":"2.2. Grupos de tipos de datos","text":"<p>Verilog tiene dos grupos principales de tipos de datos: net y variable.</p> <p>Grupo net:  Los tipos de datos del grupo de net representan las conexiones f\u00edsicas entre componentes de hardware. Se utilizan como salidas de asignaciones continuas (continuous assignments) y como se\u00f1ales de conexi\u00f3n entre distintos m\u00f3dulos. El tipo de datos m\u00e1s utilizado en este grupo es wire. Como su nombre indica, representa un cable de conexi\u00f3n.</p> <p>El tipo de datos wire representa una se\u00f1al de 1 bit, como:</p> <p><pre><code>wire po, p1; // dos se\u00f1ales de 1 bit\n</code></pre> Cuando una colecci\u00f3n de se\u00f1ales se agrupa en un bus, podemos representarlo mediante una arreglo unidimensional (vector), como: <pre><code>wire [7:0]  datal, data2; // bus de 8 bits\nwire [31:0] addr;         // direccion de 32 bits\nwire [0:7] addr;          // orden ascendete debe evitarse\n</code></pre> Aunque el rango del \u00edndice puede ser descendente (como en <code>[7:0]</code> ) o ascendente (como en <code>[0:7]</code> ), se prefiere el primero ya que la posici\u00f3n m\u00e1s a la izquierda (es decir, 7) corresponde al MSB de un n\u00famero binario.</p> <p>A veces se necesita una matriz bidimensional para representar una memoria. Por ejemplo, una memoria de 32 por 4 (es decir, una memoria tiene 32 palabras y cada palabra tiene 4 bits de ancho) puede representarse como:</p> <pre><code>wire [3:0] mem1 [31:0];   // memoria de 32 por 4\n</code></pre> <p>Grupo variable: Los tipos de datos del grupo variable representan el almacenamiento abstracto en el modelado de comportamiento (behavioral modeling) y se utilizan en las salidas de las asignaciones de procedimiento (procedural assignments). Hay cinco tipos de datos en este grupo: <code>reg</code>, <code>integer</code>, <code>real</code>, <code>time</code> y <code>realtime</code>. El tipo de datos m\u00e1s utilizado en este grupo es <code>reg</code> y puede sintetizarse. El circuito inferido puede contener o no componentes f\u00edsicos de almacenamiento. Los tres \u00faltimos tipos de datos s\u00f3lo pueden utilizarse en modelado y simulaci\u00f3n. </p>"},{"location":"getting_started/verilog_reference/#23-representacion-numerica","title":"2.3. Representaci\u00f3n num\u00e9rica","text":"<p>Una constante entera en Verilog puede representarse en varios formatos. Su forma general es: <pre><code>[sign][size]'[base][value]\n</code></pre></p> <p>El t\u00e9rmino <code>[size]</code> especifica el n\u00famero de bits de un n\u00famero. Es opcional. El n\u00famero se conoce como n\u00famero dimensionado (sized number) cuando existe un t\u00e9rmino <code>[size]</code> y como n\u00famero no dimensionado (unsized number) en caso contrario. </p> <p>El t\u00e9rmino <code>[base]</code> especifica la base del n\u00famero, que pueden ser los siguientes:</p> Tabla 2. Diferentes bases. Base Descripci\u00f3n d decimal b binary h hexadecimal o octal <p>El t\u00e9rmino <code>[value]</code> especifica el valor del n\u00famero en la base correspondiente. Puede incluirse el car\u00e1cter de gui\u00f3n bajo <code>_</code> para mayor claridad.</p> <p>Sized number: Un n\u00famero con tama\u00f1o especificado describe expl\u00edcitamente el n\u00famero de bits. Si el tama\u00f1o del valor es menor que el t\u00e9rmino <code>[size]</code> especificado, se rellenan ceros delante para extender el n\u00famero, excepto en varios casos especiales. El valor <code>z</code> o <code>x</code> se rellena si el MSB del valor es <code>z</code> o <code>x</code>, y se rellena con el MSB si se utiliza el tipo de datos con signo (<code>signed</code>).</p> <p>Unsized number: Un n\u00famero sin tama\u00f1o  especificado omite el t\u00e9rmino <code>[size]</code>. Su tama\u00f1o real depende del ordenador anfitri\u00f3n, pero debe ser de al menos 32 bits. El t\u00e9rmino <code>'[base]</code> tambi\u00e9n puede omitirse si el n\u00famero est\u00e1 en formato decimal. </p> Tabla 3. Ejemplos de sized numbers y unsized numbers. N\u00famero Valor almacenado Comentarios 8'b00000111 00000111 8'b0000_0111 10101010 Se ignora el <code>_</code> 8'o5 00000101 8'h5f 01011111 8'd8 00001000 8'b0 00000000 0 extendido 8'b1 00000001 1 extendido -8'b00000001 11111111 Complemento 2 de 00000001 1 000...001 Extendido a 32 bits -1 111...111 Extendido a 32 bits"},{"location":"getting_started/verilog_reference/#3-esqueleto-del-programa","title":"3. Esqueleto del programa","text":"<p>Como su nombre indica, el HDL se utiliza para describir hardware. Cuando desarrollamos o examinamos un c\u00f3digo Verilog, es mucho m\u00e1s f\u00e1cil de comprender si pensamos en t\u00e9rminos de \"organizaci\u00f3n de hardware\" en lugar de \"algoritmo secuencial\". La mayor\u00eda de los c\u00f3digos Verilog siguen un esqueleto b\u00e1sico que consta de tres partes:</p> <ol> <li>Declaraci\u00f3n de puertos I/O.</li> <li>Declaraci\u00f3n de se\u00f1ales.</li> <li>Cuerpo del m\u00f3dulo.</li> </ol>"},{"location":"getting_started/verilog_reference/#31-declaracion-de-puertos-io","title":"3.1. Declaraci\u00f3n de puertos I/O","text":"<p>La declaraci\u00f3n de puertos  especifica los modos, tipos de datos y nombres de los puertos I/O del m\u00f3dulo. La sintaxis es: <pre><code>module [module_name] (\n  [mode] [data_type] [port_name],\n  [mode] [data_type] [port_name],\n  . . .\n  [mode] [data_type] [port_name]\n);\n</code></pre></p> <p>El <code>[mode]</code> puede ser <code>input</code>, <code>output</code> o <code>inout</code>, que representan el puerto de entrada, salida o bidireccional, respectivamente. N\u00f3tese que no hay coma en la \u00faltima declaraci\u00f3n. El t\u00e9rmino <code>[data-type]</code> puede omitirse si es <code>wire</code>. Por ejemplo:</p> Versi\u00f3n 1Versi\u00f3n 2 <pre><code>module mymodule (\n  input  wire i1, i1,\n  output wire o1\n);\n</code></pre> <pre><code>module mymodule (\n  input  i1, i1,\n  output o1\n);\n</code></pre>"},{"location":"getting_started/verilog_reference/#32-cuerpo-del-programa","title":"3.2. Cuerpo del programa","text":"<p>A diferencia de un programa en lenguaje C, en el que las sentencias se ejecutan secuencialmente, el cuerpo del programa de un m\u00f3dulo Verilog sintetizable puede considerarse como una colecci\u00f3n de partes de circuito. Estas partes se operan en paralelo y se ejecutan concurrentemente. Hay varias maneras de describir una parte:</p> <ul> <li>Asignaci\u00f3n continua (continuous assignment).</li> <li>Bloque <code>always</code>.</li> <li>Instanciaci\u00f3n de m\u00f3dulos (module instantiation).</li> </ul> <p>La primera forma de describir una parte de un circuito es mediante una asignaci\u00f3n continua. Es \u00fatil para circuitos combinacionales simples. Su sintaxis simplificada es <pre><code>assign [signal_name] = [expression];\n</code></pre> Cada asignaci\u00f3n continua puede considerarse como una parte del circuito. La se\u00f1al del lado izquierdo es la salida y las se\u00f1ales utilizadas en la expresi\u00f3n del lado derecho son las entradas. La expresi\u00f3n describe la funci\u00f3n de este circuito. Por ejemplo, considere la siguiente sentencia: <pre><code>assign eq = p0 | p1;\n</code></pre> Es un circuito que realiza la operaci\u00f3n or. Cuando <code>p0</code> o <code>p1</code> cambian de valor, se activa esta sentencia y se eval\u00faa la expresi\u00f3n. El nuevo valor se asigna a <code>eq</code> despu\u00e9s del retardo de propagaci\u00f3n.</p> <p>La segunda forma de describir una parte del circuito es utilizando un bloque <code>always</code>. Dentro del bloque <code>always</code> se utilizan asignaciones procedimentales (procedural assignments) m\u00e1s abstractas, por lo que puede utilizarse para describir el funcionamiento de circuitos m\u00e1s complejos.</p> <p>La tercera forma de describir una parte del circuito es mediante la instanciaci\u00f3n de m\u00f3dulos. La instanciaci\u00f3n crea una instancia de otro m\u00f3dulo y nos permite incorporar m\u00f3dulos predise\u00f1ados como subsistemas del m\u00f3dulo actual. </p>"},{"location":"getting_started/verilog_reference/#33-declaracion-de-senales","title":"3.3 Declaraci\u00f3n de se\u00f1ales","text":"<p>La parte de la declaraci\u00f3n especifica las se\u00f1ales internas y los par\u00e1metros utilizados en el m\u00f3dulo. Las se\u00f1ales internas pueden considerarse como los cables de interconexi\u00f3n entre las partes del circuito. La sintaxis simplificada de la declaraci\u00f3n de se\u00f1ales es: <pre><code>[data_type] [port_name];\n</code></pre></p> <p>Implicit net</p> <p>En Verilog, no es necesario declarar expl\u00edcitamente un identificador. Si se omite una declaraci\u00f3n, se asume que es una red impl\u00edcita (implicit net). El tipo de dato por defecto es <code>wire</code>. Podemos eliminar las declaraciones expl\u00edcitas. Ver los siguientes c\u00f3digos que corresponden a un comparador de 1 bit en forma impl\u00edcita y explicita:</p> Expl\u00edcitoImpl\u00edcito eql.v<pre><code>module eql (\n  // I/O ports\n  input  wire i0, il,\n  output wire eq\n);\n\n  // signal declaration\n  wire p0, pl;\n\n  // body\n  // product terms\n  assign p0 = ~i0 &amp; ~il;\n  assign p1 =  i0 &amp;  il;\n  // sum of two product terms\n  assign eq = p0 | p1;\n\nendmodule\n</code></pre> eql_implicit.v<pre><code>module eql_implicit (\n  // I/O ports\n  input  i0, il,\n  output eq\n);\n\n  // no internal signal declaration\n\n\n  // body\n  // product terms must be placed in front\n  assign p0 = ~i0 &amp; ~il;  // implicit declaration\n  assign p1 =  i0 &amp;  il;  // implicit declaration\n  // sum of two product terms\n  assign eq = p0 | p1;\n\nendmodule\n</code></pre> <p>Aunque el c\u00f3digo es m\u00e1s compacto, puede introducir errores sutiles de identificadores mal escritos. Para mayor claridad y documentaci\u00f3n, en recomendable siempre utilizar declaraciones expl\u00edcitas.</p>"},{"location":"getting_started/verilog_reference/#4-descripcion-estructural","title":"4. Descripci\u00f3n estructural","text":"<p>Un sistema digital suele estar compuesto por varios subsistemas m\u00e1s peque\u00f1os. Esto nos permite construir un gran sistema a partir de componentes m\u00e1s sencillos o predise\u00f1ados. Verilog proporciona un mecanismo, conocido como instanciaci\u00f3n de m\u00f3dulos (module instantiation), para realizar esta tarea. Este tipo de c\u00f3digo se denomina descripci\u00f3n estructural (structural description).</p> <p>Analicemos un comparador de 2 bits. Sean las entradas <code>a</code> y <code>b</code> y la salida <code>check</code>. La se\u00f1al <code>check</code> es verdadera cuando ambos bits de <code>a</code> y <code>b</code> son iguales. Una alternativa al dise\u00f1o del comparador de 2 bits es utilizar comparadores de 1 bit previamente construidos como bloques de construcci\u00f3n. Dos comparadores de 1 bit se utilizan para comprobar los dos bits individuales y sus resultados se alimentan a una compuerta and. La se\u00f1al check es verdadera s\u00f3lo cuando ambos bits son iguales. En los siguientes c\u00f3digos se muestran la descripci\u00f3n a nivel compuerta y utilizando una descripci\u00f3n estructural.</p> EstructuralNivel compuerta eq2.v<pre><code>module eq2 (\n  input  [1:0] a, b,\n  output check\n);\n\n  // signal declaration\n  wire e0, e1;\n\n  // instantiate two 1-bit comparators\n  eq1 eq_bit0_unit (.i0(a[0]), .i1(b[0]), .eq(e0));\n  eq1 eq_bit1_unit (.i0(a[1]), .i1(b[1]), .eq(e1));\n  // a and b are equal if individual bits are equal\n  assign check = e0 &amp; e1;\n\nendmodule\n</code></pre> eq2_sop.v<pre><code>module eq2_sop (\n  input  [1:0] a, b,\n  output check\n);\n\n  // signal declaration\n  wire p0, pl, p2, p3;\n\n  // product terms\n  assign p0 = (~a[1] &amp; ~b[1]) &amp; (~a[0] &amp; ~b[0]);\n  assign p1 = (~a[1] &amp; ~b[1]) &amp; ( a[0] &amp;  b[0]);\n  assign p2 = ( a[1] &amp;  b[1]) &amp; (~a[0] &amp; ~b[0]);\n  assign p3 = ( a[1] &amp;  b[1]) &amp; ( a[0] &amp;  b[0]);\n  // sum of two product terms\n  assign check = p0 | p1 | p2 | p3;\n\nendmodule\n</code></pre> <p>El c\u00f3digo incluye dos sentencias de instanciaci\u00f3n de m\u00f3dulos. La sintaxis simplificada de la instanciaci\u00f3n de m\u00f3dulos es la siguiente:</p> <pre><code>[module_name] [instance_name] (\n  .[port_name]([signal_name]),\n  .[port_name]([signal_name]),\n  . . .\n  .[port_name]([signal_name])\n);\n</code></pre>"},{"location":"getting_started/verilog_reference/#41-conexion-por-nombre","title":"4.1 Conexi\u00f3n por nombre","text":"<p>La primera parte de la declaraci\u00f3n especifica qu\u00e9 componente se utiliza. El t\u00e9rmino <code>[module_name]</code> indica el nombre del m\u00f3dulo y el t\u00e9rmino <code>[instance_name]</code> proporciona un id \u00fanico para una instancia. La segunda parte es la conexi\u00f3n de puertos, que indica las conexiones entre los puertos I/O de un m\u00f3dulo instanciado (el m\u00f3dulo de nivel inferior) y las se\u00f1ales externas utilizadas en el m\u00f3dulo actual (el m\u00f3dulo de nivel superior). Esta forma de asignaci\u00f3n se conoce como conexi\u00f3n por nombre (connection by name). El orden de los pares puerto-nombre y se\u00f1al-nombre no importa.</p> <p>El mapeo de puertos refleja las conexiones de un diagrama a bloques. La declaraci\u00f3n de instanciaci\u00f3n del componente representa un circuito encapsulado en una \"caja negra\" cuya funci\u00f3n se define en otro m\u00f3dulo.</p> <p>Este ejemplo demuestra la estrecha relaci\u00f3n que existe entre un diagrama de bloques y el c\u00f3digo. El c\u00f3digo es esencialmente una descripci\u00f3n textual de un esquema. </p>"},{"location":"getting_started/verilog_reference/#42-conexion-por-nombre-conexion-por-lista-ordenada","title":"4.2 Conexi\u00f3n por nombre conexi\u00f3n por lista ordenada","text":"<p>Un esquema alternativo para asociar los puertos y las se\u00f1ales externas es la conexi\u00f3n por lista ordenada (connection by ordered list). En este esquema, los nombres de los puertos del m\u00f3dulo de nivel inferior se omiten y las se\u00f1ales del m\u00f3dulo de nivel superior se enumeran en el mismo orden que la declaraci\u00f3n de puertos del m\u00f3dulo de nivel inferior. Con este esquema, las dos declaraciones de instanciaci\u00f3n de m\u00f3dulos del comparador de 2 bits pueden reescribirse como:</p> <p><pre><code>eq1 eq_bit0_unit (a[0], b[0], e0);\neq1 eq_bit1_unit (a[1], b[1], e1);\n</code></pre> Aunque este esquema hace el c\u00f3digo m\u00e1s compacto, es propenso a errores, especialmente para un m\u00f3dulo con muchos puertos I/O. Por ejemplo, si modificamos el c\u00f3digo del m\u00f3dulo de nivel inferior y cambiamos el orden de dos puertos en la declaraci\u00f3n de puertos, tambi\u00e9n habr\u00e1 que corregir todos los m\u00f3dulos instanciados. Si esto se hace accidentalmente durante la edici\u00f3n del c\u00f3digo, el orden alterado de los puertos puede no detectarse durante la s\u00edntesis y dar lugar a errores dif\u00edciles de encontrar. </p>"},{"location":"getting_started/verilog_reference/#5-operadores","title":"5. Operadores","text":"Tabla 4. Operadores en Verilog. Tipo de operaci\u00f3n S\u00edmbolo de operador Descripci\u00f3n N\u00famero de operandos Aritm\u00e9ticos + Suma 2 - Resta 2 * Multiplicaci\u00f3n 2 / Divisi\u00f3n 2 % M\u00f3dulo 2 ** Exponenciaci\u00f3n 2 Desplazamiento &gt;&gt; Desplazamiento l\u00f3gico a la derecha (llena con ceros) 2 &lt;&lt; Desplazamiento l\u00f3gico a la izquierda (llena con ceros) 2 &gt;&gt;&gt; Desplazamiento aritm\u00e9tico a la derecha (mantiene signo) 2 &lt;&lt;&lt; Desplazamiento aritm\u00e9tico a la izquierda (mantiene signo) 2 Relacional &gt; Mayor que 2 &lt; Menor que 2 &gt;= Mayor o igual que 2 &lt;= Menor o igual que 2 Igualdad == Igual 2 != Diferente 2 === Igualdad de casos 2 !== Desigualdad de casos 2 Bitwise ~ Negaci\u00f3n bitwise 1 &amp; AND bitwise 2 | OR bitwise 2 ^ XOR bitwise 2 Reducci\u00f3n &amp; Reducci\u00f3n AND 1 | Reducci\u00f3n OR 1 ^ Reducci\u00f3n XOR 1 L\u00f3gicos ! Negaci\u00f3n l\u00f3gica 1 &amp;&amp; AND l\u00f3gica 2 || OR l\u00f3gica 2 Concatenaci\u00f3n { } Concatenaci\u00f3n Cualquier { { } } Replicaci\u00f3n Cualquier Condicional ? : Condicional 3 Tabla 5. Precedencia de los operadores . Operador Precedencia !    ~    +    -    (unarios) m\u00e1s alto ** *    /    % +    -    (binario) &gt;&gt;    &lt;&lt;    &gt;&gt;&gt;    &lt;&lt;&lt; &lt;    &lt;=    &gt;    &gt;= ==    !=    ===    !== &amp; ^ | &amp;&amp; || ?: m\u00e1s bajo"},{"location":"getting_started/verilog_reference/#referencias","title":"Referencias","text":"<ol> <li> <p>S. D. Brown y Z. G. Vranesic, Fundamentals of digital logic with Verilog design, Third edition. New York: McGraw-Hill Higher Education, 2014.\u00a0\u21a9</p> </li> <li> <p>S. Palnitkar, Verilog HDL: A Guide to Digital Design and Synthesis, Prentice-Hall, Inc, 1996.\u00a0\u21a9</p> </li> <li> <p>Pong P. Chu, FPGA Prototyping by Verilog Examples Xilinx Spartan-3 Version, Wiley &amp; Sons, Incorporated, John, 2008.\u00a0\u21a9</p> </li> </ol>"},{"location":"proyectos/","title":"Proyectos","text":""},{"location":"proyectos/10_rs232/rs232/","title":"RS232","text":""},{"location":"proyectos/10_rs232/rs232/#1-introtroduccion","title":"1. Introtroducci\u00f3n","text":"<p>Diagrama de tiempo</p> <p> </p> Figura 1. Diagrama a bloques. <p> </p> Figura 3. Diagrama como caja negra."},{"location":"proyectos/10_rs232/rs232/#2-codigos","title":"2. C\u00f3digos","text":""},{"location":"proyectos/10_rs232/rs232/#21-multiplexor","title":"2.1. Multiplexor","text":"mux_tx.v<pre><code>module mux_tx(\n  input [7:0] d_i,     // Datos a transmitir\n  input       pbit_i,  // Bit de paridad\n  input [3:0] sel_i,   // Selector de bit\n  output  reg tx_o     // Transmision\n);\n\n  always @(d_i, pbit_i, sel_i) begin\n    case (sel_i)\n      4'b0000 : tx_o = 1'b1;    // Stop bit\n      4'b0001 : tx_o = 1'b0;    // Start bit\n      4'b0010 : tx_o = d_i[0];  // LSB de d_i \n      4'b0011 : tx_o = d_i[1];\n      4'b0100 : tx_o = d_i[2];\n      4'b0101 : tx_o = d_i[3];\n      4'b0110 : tx_o = d_i[4];\n      4'b0111 : tx_o = d_i[5];\n      4'b1000 : tx_o = d_i[6];\n      4'b1001 : tx_o = d_i[7];  \n      4'b1010 : tx_o = pbit_i;  // Bit de paridad\n      default : tx_o = 1'b1;    // Stop bit\n    endcase\n  end\n\nendmodule\n</code></pre>"},{"location":"proyectos/10_rs232/rs232/#22-paridad","title":"2.2. Paridad","text":"parity.v"},{"location":"proyectos/10_rs232/rs232/#23-divisor-de-frecuencia","title":"2.3. Divisor de frecuencia","text":"\\[ \\text{BAUD} = \\frac{1}{9600} \\cdot 100 \\text{MHz} - 1  = 10415.66 \\approx 10415 \\] \\[ \\log_{2} (10415) = 13.34 \\approx 14 \\] freq_div.v"},{"location":"proyectos/10_rs232/rs232/#24-fsm-transmision","title":"2.4. FSM transmisi\u00f3n","text":"Figura 3. M\u00e1quina de estados de transmisi\u00f3n con protocolo Rs232. fsm_tx.v<pre><code>module fsm_tx (\n  input            rst_i,   // Reset del sistema\n  input            clk_i,   // Reloj del sistema\n  input            sttx_i,  // Start\n  input            z_i,     // Base de tiempo\n  input            psel_i,  // Selector de paridad\n  output reg [3:0] sel_o,   // Habilitador de mux\n  output reg       eot_o    // Fin de transmision\n);\n\n  localparam [3:0] s0  = 4'b0000, // Wait y stop bit\n                   s1  = 4'b0001, // Sincronizacion\n                   s2  = 4'b0010, // Start bit\n                   s3  = 4'b0011, // D0\n                   s4  = 4'b0100, // D1\n                   s5  = 4'b0101, // D2\n                   s6  = 4'b0110, // D3\n                   s7  = 4'b0111, // D4\n                   s8  = 4'b1000, // D5\n                   s9  = 4'b1001, // D6\n                   s10 = 4'b1010, // D7\n                   s11 = 4'b1011; // Parity\n\n  reg [3:0] present_state, next_state;\n\n  // Logica proximo estado y decodificacion de salida\n  always @(sttx_i, z_i, psel_i, present_state) begin\n    next_state = present_state;\n    sel_o = 4'b0000; eot_o = 1'b0;\n    case (present_state)\n      s0 : begin // Wait y stop bit\n             sel_o = 4'b0000; eot_o = 1'b1;\n             if (sttx_i)\n               next_state = s1;\n           end\n      s1 : begin // Sincronizacion\n             sel_o = 4'b0000; eot_o = 1'b0;\n             if (z_i)\n               next_state = s2;\n           end\n      s2 : begin // Start bit\n             sel_o = 4'b0001; eot_o = 1'b0;\n             if (z_i)\n               next_state = s3;\n           end\n      s3 : begin // D0\n             sel_o = 4'b0010; eot_o = 1'b0;\n             if (z_i)\n               next_state = s4;\n           end\n      s4 : begin // D1\n             sel_o = 4'b0011; eot_o = 1'b0;\n             if (z_i)\n               next_state = s5;\n           end\n      s5 : begin // D2\n             sel_o = 4'b0100; eot_o = 1'b0;\n             if (z_i)\n               next_state = s6;\n           end\n      s6 : begin // D3\n             sel_o = 4'b0101; eot_o = 1'b0;\n             if (z_i)\n               next_state = s7;\n           end\n      s7 : begin // D4\n             sel_o = 4'b0110; eot_o = 1'b0;\n             if (z_i)\n               next_state = s8;\n           end\n      s8 : begin // D5\n             sel_o = 4'b0111; eot_o = 1'b0;\n             if (z_i)\n               next_state = s9;\n           end\n      s9 : begin // D6\n             sel_o = 4'b1000; eot_o = 1'b0;\n             if (z_i)\n               next_state = s10;\n           end\n     s10 : begin // D7\n             sel_o = 4'b1001; eot_o = 1'b0;\n             if (z_i) begin\n               if (psel_i)\n                 next_state = s11;\n               else\n                 next_state = s0;\n             end\n           end\n     s11 : begin // Paridad\n             sel_o = 4'b1010; eot_o = 1'b0;\n             if (z_i)\n               next_state = s0;\n           end\n default : begin // Regresar a S0 por default\n             next_state = s0;\n           end\n    endcase \n  end\n\n  // Registro de estado\n  always @(posedge clk_i, posedge rst_i) begin\n    if (rst_i)\n      present_state &lt;= s0;\n    else\n      present_state &lt;= next_state;\n  end\n\nendmodule\n</code></pre>"},{"location":"proyectos/10_rs232/rs232/#25-top","title":"2.5. Top","text":"rs232_tx.v<pre><code>module rs232_tx (\n  input         rst_i,\n  input         clk_i,\n  input         sttx_i,  // Start\n  input   [7:0] d_i,     // Datos de entrada\n  input  [14:0] baud_i,  // Constante de baudios\n  input         psel_i,  // Selector de paridad\n  output        tx_o,    // Transmision\n  output        eot_o    // Fin de transmision\n);\n\n  wire       z;\n  wire       p; \n  wire [3:0] sel; \n\n  mux_tx mod_mux_tx (\n    .d_i(d_i),\n    .pbit_i(p),\n    .sel_i(sel),\n    .tx_o(tx_o)\n  );\n\n  parity_tx mod_parity_tx (\n    .d_i(d_i), \n    .pbit_o(p)\n  );\n\n  clk_div_tx #(.Width(15)) mod_clk_div_tx(\n    .rst_i(rst_i),\n    .clk_i(clk_i),\n    .en_i(1'b1),\n    .baud_i(baud_i),\n    .z_o(z)\n  );\n\n  fsm_tx mod_fsm_tx (\n    .rst_i(rst_i),\n    .clk_i(clk_i),\n    .sttx_i(sttx_i),\n    .z_i(z),\n    .psel_i(psel_i),\n    .sel_o(sel),\n    .eot_o(eot_o)\n  );\n\n\nendmodule\n</code></pre>"},{"location":"proyectos/10_rs232/rs232/#3-verificacion","title":"3. Verificaci\u00f3n","text":"rs232_tx_tb.v<pre><code>`timescale 1ns / 100 ps\n`include \"mux_tx.v\"\n`include \"parity_tx.v\"\n`include \"clk_div_tx.v\"\n`include \"fsm_tx.v\"\n`include \"rs232_tx.v\"\n\nmodule rs232_tx_tb ();\n  // Definici\u00f3n de se\u00f1ales de entrada y salida\n  reg         rst;\n  reg         clk;\n  reg         sttx;\n  reg   [7:0] d;\n  reg  [14:0] baud;\n  reg         psel;\n  wire        tx;\n  wire        eot;\n\n  // Instanciacion del modulo\n  rs232_tx dut (\n    .rst_i(rst), \n    .clk_i(clk),\n    .sttx_i(sttx),\n    .d_i(d),\n    .baud_i(baud),\n    .psel_i(psel),\n    .tx_o(tx),\n    .eot_o(eot)\n  );\n\n  // Generador de reloj de 100 MHz con duty-cycle de 50 %\n  always #5 clk = ~clk;\n\n  // Secuencia de reset y condiciones iniciales\n  initial begin\n    clk = 0; rst = 1; sttx = 0; d = 8'b01110011; baud = 15'd10415; psel = 0; #10;\n             rst = 0;                                                        #10;\n  end\n\n  initial begin\n    // Configuracion de archivos de salida\n    $dumpfile(\"rs232_tx_tb.vcd\");\n    $dumpvars(0,rs232_tx_tb);\n\n    // Sincronizacion\n    #30;\n\n    //Estimulos de prueba\n    sttx = 1; #10;\n    sttx = 0; #10;\n\n    // Esperar que acabe la transmision\n    #(10*10415*11);\n\n\n    //Estimulos de prueba\n    psel = 1; #10;\n    sttx = 1; #10;\n    sttx = 0; #10;\n\n    // Esperar que acabe la transmision\n    #(10*10415*12);\n\n    $display(\"Test completed\");\n    $finish;\n  end\n\nendmodule;\n</code></pre>"},{"location":"proyectos/10_rs232/rs232/#4-resultados","title":"4. Resultados","text":"Figura 4. Resultados de simulaci\u00f3n en GTKWave de transmisi\u00f3n con protocolo RS232."}]}